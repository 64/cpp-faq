<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>What are 'Include Guards' and `#pragma once`? | C++ FAQ</title><meta name=keywords content="beginner"><meta name=description content="Include guards, or sometimes called macro guards, header guards, or file guards are a common C/C++ idiom that allows including a header file multiple times safely. The non-standard preprocessor directive #pragma once is an almost equivalent alternative to this idiom.
The Problem The preprocessor directive #include effectively copies the named header into our source file. If we #include a header file more than once, this will result in redefinitions and possibly compiler errors."><meta name=author content><link rel=canonical href=https://64.github.io/cpp-faq/include-guards-pragma-once/><link href=/cpp-faq/assets/css/stylesheet.min.746a86b58bb2b052b5e4df8216510494f04f81e62c08d626150c26c69ca929da.css integrity="sha256-dGqGtYuysFK15N+CFlEElPBPgeYsCNYmFQwmxpypKdo=" rel="preload stylesheet" as=style><link rel=icon href=https://64.github.io/cpp-faq/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://64.github.io/cpp-faq/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://64.github.io/cpp-faq/favicon-32x32.png><link rel=apple-touch-icon href=https://64.github.io/cpp-faq/apple-touch-icon.png><link rel=mask-icon href=https://64.github.io/cpp-faq/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><meta property="og:title" content="What are 'Include Guards' and `#pragma once`?"><meta property="og:description" content="Include guards, or sometimes called macro guards, header guards, or file guards are a common C/C++ idiom that allows including a header file multiple times safely. The non-standard preprocessor directive #pragma once is an almost equivalent alternative to this idiom.
The Problem The preprocessor directive #include effectively copies the named header into our source file. If we #include a header file more than once, this will result in redefinitions and possibly compiler errors."><meta property="og:type" content="article"><meta property="og:url" content="https://64.github.io/cpp-faq/include-guards-pragma-once/"><meta property="og:site_name" content="C++ FAQ"><meta name=twitter:card content="summary"><meta name=twitter:title content="What are 'Include Guards' and `#pragma once`?"><meta name=twitter:description content="Include guards, or sometimes called macro guards, header guards, or file guards are a common C/C++ idiom that allows including a header file multiple times safely. The non-standard preprocessor directive #pragma once is an almost equivalent alternative to this idiom.
The Problem The preprocessor directive #include effectively copies the named header into our source file. If we #include a header file more than once, this will result in redefinitions and possibly compiler errors."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Faqs","item":"https://64.github.io/cpp-faq/faq/"},{"@type":"ListItem","position":3,"name":"What are 'Include Guards' and `#pragma once`?","item":"https://64.github.io/cpp-faq/include-guards-pragma-once/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"What are 'Include Guards' and `#pragma once`?","name":"What are \u0027Include Guards\u0027 and `#pragma once`?","description":"Include guards, or sometimes called macro guards, header guards, or file guards are a common C/C++ idiom that allows including a header file multiple times safely. The non-standard …","keywords":["beginner"],"articleBody":"Include guards, or sometimes called macro guards, header guards, or file guards are a common C/C++ idiom that allows including a header file multiple times safely. The non-standard preprocessor directive #pragma once is an almost equivalent alternative to this idiom.\nThe Problem The preprocessor directive #include effectively copies the named header into our source file. If we #include a header file more than once, this will result in redefinitions and possibly compiler errors. Consider this example:\n// point.hpp  struct point { int x, y; }; // main.cpp  #include \"point.hpp\"#include \"point.hpp\"#include  int main() { point p; std::cin  p.x  p.y; std::cout  p.x  ' '  p.y  '\\n'; } This code does not compile, because we have included point.hpp twice. After these two includes are processed by the preprocessor, main.cpp (ignoring comments) will be the following:\nstruct point { int x, y; }; struct point { int x, y; }; #include  int main() { point p; std::cin  p.x  p.y; std::cout  p.x  ' '  p.y  '\\n'; } The program is ill-formed and we get a compiler error:\n:4:8: error: redefinition of 'point' struct point { ^ :1:8: note: previous definition is here struct point { ^ At this point you might think: “Okay then just don’t include it twice and the problem is solved.\". But including headers multiple times is not always easy to avoid. We could have two more header files pointmath.hpp and pointlist.hpp, both of which #include \"point.hpp\". The include-tree would look as follows:\nmain.cpp └─ pointmath.hpp └─ point.hpp └─ pointlist.hpp └─ point.hpp main.cpp indirectly includes point.hpp twice. And this is by no means unusual. Smaller standard library headers such as  or  are included by many other headers like , so each source file may have many copies of .\nSolution A: Include Guards Include guards are put around the entirety of the header file:\n// point.hpp #ifndef MYPROJECT_POINT_HPP_GUARD #define MYPROJECT_POINT_HPP_GUARD struct point { int x, y; }; #endif This idiom works by letting the preprocessor skip the entirety of the header file if MYPROJECT_POINT_HPP_GUARD has already been defined. Only the first time we include the header file, will MYPROJECT_POINT_HPP_GUARD be undefined. We #define this macro inside of the #ifndef block, so all subsequent copies of the header will not be processed. Here is how this works if we process the first two includes in main.cpp:\n#ifndef MYPROJECT_POINT_HPP_GUARD // not defined yet, so we enter the ifndef-block #define MYPROJECT_POINT_HPP_GUARD // we define the guard struct point { int x, y; }; #endif // we exit the ifndef-block #ifndef MYPROJECT_POINT_HPP_GUARD // the guard has already been defined = skip #define MYPROJECT_POINT_HPP_GUARD // this is not processed struct point { int x, y; }; #endif // we stop skipping code here #include  int main() { point p; std::cin  p.x  p.y; std::cout  p.x  ' '  p.y  '\\n'; } After processing the #ifndef blocks, the code will effectively look like this:\n#define MYPROJECT_POINT_HPP_GUARD struct point { int x, y; }; #include  int main() { point p; std::cin  p.x  p.y; std::cout  p.x  ' '  p.y  '\\n'; } We could now include our point.hpp header as many times as we want in as many headers as we want without worrying about redefining our functions and receiving compiler errors.\nNote: MYPROJECT_POINT_HPP_GUARD is an arbitrary definition, we could name it something else too. But the name should be long and unique so we don’t accidentally use the same guard twice.\nSolution B: #pragma once #pragma once is a non-standard preprocessor directive which tells the preprocessor to skip the current header if it has already been included. The goal is to achieve the same effect as our include guards, but more concisely. We can use it like this:\n// mymath.hpp #pragma once struct point { int x, y; }; At first glance, this is much more elegant than include guards and we could just use #pragma once in all cases. However, as already mentioned, #pragma directives are not part of the C or C++ standard, so the behavior is dependent on the compiler.\nOne alleged advantage of #pragma once is that it can be faster, since the preprocessor doesn’t need to read the entire file to find a matching #endif for the #ifndef directive. The file contents can be skipped at an earlier stage. However, these claims are hard to reproduce with modern compilers and practical examples.\nIt is worth noting that identifying whether a file is included multiple times is not a trival problem. In modern file systems, many symbolic links or hardlinks can lead to the same file. Usually the file contents and sometimes the timestamp are used by preprocessor to test for duplicates.\nIn most cases and with virtually every compiler, #pragma once will work as intended. But it is the subject of scepticism because it is neither fully standardized nor perfectly reliable. An example where #pragma once fails can be seen here:\n// a.hpp #pragma once struct foo {}; // b.hpp #pragma once struct foo {}; // main.cpp namespace a { #include \"a.hpp\"} namespace b { #include \"b.hpp\"} int main() { b::foo x; } We get a compiler error:\nmain.cpp:8:3: error: foo is not a member of ´b´ b::foo x; ^~~ The contents of a.hpp and b.hpp are completely identical (ignoring the comments at the top). When we attempt to #include \"b.hpp\", the preprocessor will falsely believe that b.hpp has already been included, because it is identical to a.hpp. Arguably, this is an unusual example and including inside of a namespace is considered bad practice by many. However, it shows that #pragma once is not quite as reliable as include guards.\nConclusion Include guards are a tried and tested, fully standardized, and efficient idiom which allows including a header file multiple times. Headers should be wrapped in include guards, ideally right when creating the file. Many IDEs can be configured so that they automatically add include guards when you create a new header file.\n#pragma once is a viable, but non-standard alternative for simple projects and will work most of the time, but it can produce cryptic and very hard-to-track errors. If you do measure a significant difference in compile times and want to use #pragma once anyways, you can use both include guards and #pragma once. Because include guards are unique for each file, the previously shown error would have been prevented:\n// point.hpp #pragma once #ifndef MYPROJECT_POINT_HPP_GUARD #define MYPROJECT_POINT_HPP_GUARD struct point { int x, y; }; #endif See Also  https://en.wikipedia.org/wiki/Include_guard https://en.wikipedia.org/wiki/Pragma_once https://en.cppreference.com/w/cpp/preprocessor/include  ","wordCount":"1096","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://64.github.io/cpp-faq/include-guards-pragma-once/"},"publisher":{"@type":"Organization","name":"C++ FAQ","logo":{"@type":"ImageObject","url":"https://64.github.io/cpp-faq/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://64.github.io/cpp-faq accesskey=h title="C++ FAQ (Alt + H)">C++ FAQ</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>What are &lsquo;Include Guards&rsquo; and <code>#pragma once</code>?</h1><div class=post-meta><ul class=post-tags><li><a href=https://64.github.io/cpp-faq/tags/beginner/>beginner</a></li></ul></div></header><div class=post-content><p>Include guards, or sometimes called <em>macro guards</em>, <em>header guards</em>, or <em>file guards</em> are a common C/C++ idiom that
allows including a header file multiple times safely.
The non-standard preprocessor directive <code>#pragma once</code> is an almost equivalent alternative to this idiom.</p><h2 id=the-problem>The Problem<a hidden class=anchor aria-hidden=true href=#the-problem>#</a></h2><p>The preprocessor directive <code>#include</code> effectively copies the named header into our source file.
If we <code>#include</code> a header file more than once, this will result in redefinitions and possibly compiler errors.
Consider this example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// point.hpp
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>point</span> {
    <span style=color:#66d9ef>int</span> x, y;
};
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// main.cpp
</span><span style=color:#75715e></span>
<span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;point.hpp&#34;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;point.hpp&#34;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    point p;
    std<span style=color:#f92672>::</span>cin <span style=color:#f92672>&gt;&gt;</span> p.x <span style=color:#f92672>&gt;&gt;</span> p.y;
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> p.x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>&lt;&lt;</span> p.y <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
}
</code></pre></div><p>This code does not compile, because we have included <code>point.hpp</code> twice.
After these two includes are processed by the preprocessor, <code>main.cpp</code> (ignoring comments) will be the following:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>point</span> {
    <span style=color:#66d9ef>int</span> x, y;
};
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>point</span> {
    <span style=color:#66d9ef>int</span> x, y;
};
<span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    point p;
    std<span style=color:#f92672>::</span>cin <span style=color:#f92672>&gt;&gt;</span> p.x <span style=color:#f92672>&gt;&gt;</span> p.y;
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> p.x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>&lt;&lt;</span> p.y <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
}
</code></pre></div><p>The program is ill-formed and we get a compiler error:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>&lt;source&gt;:4:8: error: redefinition of &#39;point&#39;
struct point {
       ^
&lt;source&gt;:1:8: note: previous definition is here
struct point {
       ^
</code></pre></div><p>At this point you might think: <em>&ldquo;Okay then just don&rsquo;t include it twice and the problem is solved."</em>.
But including headers multiple times is not always easy to avoid.
We could have two more header files <code>pointmath.hpp</code> and <code>pointlist.hpp</code>, both of which <code>#include "point.hpp"</code>.
The include-tree would look as follows:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>main.cpp
  └─ pointmath.hpp
       └─ point.hpp
  └─ pointlist.hpp
       └─ point.hpp
</code></pre></div><p><code>main.cpp</code> indirectly includes <code>point.hpp</code> twice.
And this is by no means unusual.
Smaller standard library headers such as <code>&lt;utility></code> or <code>&lt;new></code> are included by many other headers like <code>&lt;vector></code>, so
each source file may have many copies of <code>&lt;new></code>.</p><h2 id=solution-a-include-guards>Solution A: Include Guards<a hidden class=anchor aria-hidden=true href=#solution-a-include-guards>#</a></h2><p>Include guards are put around the entirety of the header file:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// point.hpp
</span><span style=color:#75715e></span><span style=color:#75715e>#ifndef MYPROJECT_POINT_HPP_GUARD
</span><span style=color:#75715e>#define MYPROJECT_POINT_HPP_GUARD
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>point</span> {
    <span style=color:#66d9ef>int</span> x, y;
};
<span style=color:#75715e>#endif
</span></code></pre></div><p>This idiom works by letting the preprocessor skip the entirety of the header file if <code>MYPROJECT_POINT_HPP_GUARD</code> has
already been defined.
Only the first time we include the header file, will <code>MYPROJECT_POINT_HPP_GUARD</code> be undefined.
We <code>#define</code> this macro inside of the <code>#ifndef</code> block, so all subsequent copies of the header will not be processed.
Here is how this works if we process the first two includes in <code>main.cpp</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>#ifndef MYPROJECT_POINT_HPP_GUARD </span><span style=color:#75715e>// not defined yet, so we enter the ifndef-block
</span><span style=color:#75715e></span><span style=color:#75715e>#define MYPROJECT_POINT_HPP_GUARD </span><span style=color:#75715e>// we define the guard
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>point</span> {
    <span style=color:#66d9ef>int</span> x, y;
};
<span style=color:#75715e>#endif                            </span><span style=color:#75715e>// we exit the ifndef-block
</span><span style=color:#75715e></span><span style=color:#75715e>#ifndef MYPROJECT_POINT_HPP_GUARD </span><span style=color:#75715e>// the guard has already been defined =&gt; skip
</span><span style=color:#75715e></span><span style=color:#75715e>#define MYPROJECT_POINT_HPP_GUARD </span><span style=color:#75715e>// this is not processed
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>point</span> {
    <span style=color:#66d9ef>int</span> x, y;
};
<span style=color:#75715e>#endif                            </span><span style=color:#75715e>// we stop skipping code here
</span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    point p;
    std<span style=color:#f92672>::</span>cin <span style=color:#f92672>&gt;&gt;</span> p.x <span style=color:#f92672>&gt;&gt;</span> p.y;
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> p.x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>&lt;&lt;</span> p.y <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
}
</code></pre></div><p>After processing the <code>#ifndef</code> blocks, the code will effectively look like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>#define MYPROJECT_POINT_HPP_GUARD
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>point</span> {
    <span style=color:#66d9ef>int</span> x, y;
};
<span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    point p;
    std<span style=color:#f92672>::</span>cin <span style=color:#f92672>&gt;&gt;</span> p.x <span style=color:#f92672>&gt;&gt;</span> p.y;
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> p.x <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>&lt;&lt;</span> p.y <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
}
</code></pre></div><p>We could now include our <code>point.hpp</code> header as many times as we want in as many headers as we want without worrying
about redefining our functions and receiving compiler errors.</p><p>Note: <code>MYPROJECT_POINT_HPP_GUARD</code> is an arbitrary definition, we could name it something else too.
But the name should be long and unique so we don&rsquo;t accidentally use the same guard twice.</p><h2 id=solution-b-pragma-once>Solution B: #pragma once<a hidden class=anchor aria-hidden=true href=#solution-b-pragma-once>#</a></h2><p><code>#pragma once</code> is a non-standard preprocessor directive which tells the preprocessor to skip the current header if it
has already been included.
The goal is to achieve the same effect as our include guards, but more concisely.
We can use it like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// mymath.hpp
</span><span style=color:#75715e></span><span style=color:#75715e>#pragma once
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>point</span> {
    <span style=color:#66d9ef>int</span> x, y;
};
</code></pre></div><p>At first glance, this is much more elegant than include guards and we could just use <code>#pragma once</code> in all cases.
However, as already mentioned, <code>#pragma</code> directives are not part of the C or C++ standard, so the behavior is dependent
on the compiler.</p><p>One alleged advantage of <code>#pragma once</code> is that
<a href=https://web.archive.org/web/20080930061318/http://www.gamesfromwithin.com/articles/0501/000067.html>it can be faster</a>,
since the preprocessor doesn&rsquo;t need to read the entire file to find a matching <code>#endif</code> for the <code>#ifndef</code> directive.
The file contents can be skipped at an earlier stage.
However, these claims are hard to reproduce with modern compilers and practical examples.</p><p>It is worth noting that identifying whether a file is included multiple times is not a trival problem.
In modern file systems, many symbolic links or hardlinks can lead to the same file.
Usually the file contents and sometimes the timestamp are used by preprocessor to test for duplicates.</p><p>In most cases and with virtually every compiler, <code>#pragma once</code> will work as intended.
But it is the subject of scepticism because it is neither fully standardized nor perfectly reliable.
An example where <code>#pragma once</code> fails can be seen here:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// a.hpp
</span><span style=color:#75715e></span><span style=color:#75715e>#pragma once
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>foo</span> {};
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// b.hpp
</span><span style=color:#75715e></span><span style=color:#75715e>#pragma once
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>foo</span> {};
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// main.cpp
</span><span style=color:#75715e></span><span style=color:#66d9ef>namespace</span> a {
<span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;a.hpp&#34;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>}
<span style=color:#66d9ef>namespace</span> b {
<span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;b.hpp&#34;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>}
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
  b<span style=color:#f92672>::</span>foo x;
}
</code></pre></div><p>We get a compiler error:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>main.cpp:8:3: error: foo is not a member of ´b´
   b::foo x;
   ^~~
</code></pre></div><p>The contents of <code>a.hpp</code> and <code>b.hpp</code> are completely identical (ignoring the comments at the top).
When we attempt to <code>#include "b.hpp"</code>, the preprocessor will falsely believe that <code>b.hpp</code> has already been included,
because it is identical to <code>a.hpp</code>.
Arguably, this is an unusual example and including inside of a <code>namespace</code> is considered bad practice by many.
However, it shows that <code>#pragma once</code> is not quite as reliable as include guards.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Include guards are a tried and tested, fully standardized, and efficient idiom which allows including a header file
multiple times.
Headers should be wrapped in include guards, ideally right when creating the file.
Many IDEs can be configured so that they automatically add include guards when you create a new header file.</p><p><code>#pragma once</code> is a viable, but non-standard alternative for simple projects and will work most of the time, but
it can produce cryptic and very hard-to-track errors.
If you do measure a significant difference in compile times and want to use <code>#pragma once</code> anyways, you can use both
include guards and <code>#pragma once</code>.
Because include guards are unique for each file, the previously shown error would have been prevented:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>// point.hpp
</span><span style=color:#75715e></span><span style=color:#75715e>#pragma once
</span><span style=color:#75715e>#ifndef MYPROJECT_POINT_HPP_GUARD
</span><span style=color:#75715e>#define MYPROJECT_POINT_HPP_GUARD
</span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>point</span> {
    <span style=color:#66d9ef>int</span> x, y;
};
<span style=color:#75715e>#endif
</span></code></pre></div><h3 id=see-also>See Also<a hidden class=anchor aria-hidden=true href=#see-also>#</a></h3><ul><li><a href=https://en.wikipedia.org/wiki/Include_guard>https://en.wikipedia.org/wiki/Include_guard</a></li><li><a href=https://en.wikipedia.org/wiki/Pragma_once>https://en.wikipedia.org/wiki/Pragma_once</a></li><li><a href=https://en.cppreference.com/w/cpp/preprocessor/include>https://en.cppreference.com/w/cpp/preprocessor/include</a></li></ul></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://64.github.io/cpp-faq>C++ FAQ</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/cpp-faq/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>