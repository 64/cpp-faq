<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>What are fixed-width integers? | C++ FAQ</title><meta name=keywords content="beginner"><meta name=description content="Fixed-width integers are integral types with a fixed number of bits. The C++ standard only specifies a minimum byte count for types such as short, int and long. Fixed-width integers guarantee a specific size, but their use can have an impact on portability, since they are not supported by all platforms.
Fixed-width integer types These can be used by including <cstdint>. The intX_t types are signed integers with exactly X bits."><meta name=author content><link rel=canonical href=https://64.github.io/cpp-faq/fixed-width-integers/><link href=/cpp-faq/assets/css/stylesheet.min.746a86b58bb2b052b5e4df8216510494f04f81e62c08d626150c26c69ca929da.css integrity="sha256-dGqGtYuysFK15N+CFlEElPBPgeYsCNYmFQwmxpypKdo=" rel="preload stylesheet" as=style><link rel=icon href=https://64.github.io/cpp-faq/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://64.github.io/cpp-faq/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://64.github.io/cpp-faq/favicon-32x32.png><link rel=apple-touch-icon href=https://64.github.io/cpp-faq/apple-touch-icon.png><link rel=mask-icon href=https://64.github.io/cpp-faq/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><meta property="og:title" content="What are fixed-width integers?"><meta property="og:description" content="Fixed-width integers are integral types with a fixed number of bits. The C++ standard only specifies a minimum byte count for types such as short, int and long. Fixed-width integers guarantee a specific size, but their use can have an impact on portability, since they are not supported by all platforms.
Fixed-width integer types These can be used by including <cstdint>. The intX_t types are signed integers with exactly X bits."><meta property="og:type" content="article"><meta property="og:url" content="https://64.github.io/cpp-faq/fixed-width-integers/"><meta property="og:site_name" content="C++ FAQ"><meta name=twitter:card content="summary"><meta name=twitter:title content="What are fixed-width integers?"><meta name=twitter:description content="Fixed-width integers are integral types with a fixed number of bits. The C++ standard only specifies a minimum byte count for types such as short, int and long. Fixed-width integers guarantee a specific size, but their use can have an impact on portability, since they are not supported by all platforms.
Fixed-width integer types These can be used by including <cstdint>. The intX_t types are signed integers with exactly X bits."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Faqs","item":"https://64.github.io/cpp-faq/faq/"},{"@type":"ListItem","position":3,"name":"What are fixed-width integers?","item":"https://64.github.io/cpp-faq/fixed-width-integers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"What are fixed-width integers?","name":"What are fixed-width integers?","description":"Fixed-width integers are integral types with a fixed number of bits. The C++ standard only specifies a minimum byte count for types such as short, int and long. Fixed-width …","keywords":["beginner"],"articleBody":"Fixed-width integers are integral types with a fixed number of bits. The C++ standard only specifies a minimum byte count for types such as short, int and long. Fixed-width integers guarantee a specific size, but their use can have an impact on portability, since they are not supported by all platforms.\nFixed-width integer types These can be used by including . The intX_t types are signed integers with exactly X bits. uintX_t types are the same, but unsigned.\n std::int8_t / std::uint8_t (1 byte)  Note: These are treated as characters on most systems. When printing variables of this type, they might show up as their ASCII equivalent.   std::int16_t / std::uint16_t (2 bytes) std::int32_t / std::uint32_t (4 bytes) std::int64_t / std::uint64_t (8 bytes)  Note: The number of bytes is the number of bits in the type, divided by the number of bits in one byte. On architectures where bits per byte != 8, some or even all of these types may not be defined.\nThe more portable alternative To optimize integral types for faster access times and to ensure portability with more exotic architectures, the following types allow the compiler to choose a suitable integer size, while also ensuring a minimum number of bits.\nFor every std::(u)intX_t type there is a std::(u)int_leastX_t that represents the smallest integral type with at least X bits. These optimize for memory.\nLikewise, there are types that optimize for speed: std::(u)int_fastX_t (the fastest integral type with at least X bits).\nFixed-width integer range Unsigned integers with X bits range from 0 to 2X- 1. Signed integers with X bits typically range from -2X-1to 2X-1- 1, assuming two’s complement representation.\nAccurate, platform-specific ranges can also be found in :\n INTX_MIN / INTX_MAX (minimum and maximum values for std::intX_t and std::uintX_t) INT_LEASTX_MIN / INT_LEASTX_MAX (minimum and maximum values for std::int_leastX_t and std::uint_leastX_t) INT_FASTX_MIN / INT_FASTX_MAX (minimum and maximum values for std::int_fastX_t and std::uint_fastX_t)  In C++, the standardized way of getting the limits of various numeric types is the class template std::numeric_limits defined in :\n std::numeric_limits.min() - minimum value for an integer of type T std::numeric_limits.max() - maximum value for an integer of type T  Example #include #include  // for CHAR_BIT#include  int main() { // 16-bit (2-byte) integer  std::uint16_t year = 1984; // Check size in bytes, will usually be 2  std::cout  year  \": \"  sizeof(year)  \" bytes\"  std::endl; // Multiply by CHAR_BIT (number of bits in one byte) to get size in bits  std::cout  \"Size of fastest integer with at least 16 bits: \"  (CHAR_BIT * sizeof(std::int_fast16_t))  std::endl; std::cout  \"Maximum value: \"  INT_FAST16_MAX  std::endl; return 0; } Compiling and running the above program with gcc on a 64-bit Intel architecture produces the following result:\n1984: 2 bytes Size of fastest integer with at least 16 bits: 64 Maximum value: 9223372036854775807 The std::uint16_t variable is 2 bytes wide, as expected. The compiler decided that the fastest integral type with at least 16 bits is the 64-bit integer on this architecture.\nSee Also  https://en.cppreference.com/w/cpp/types/integer https://en.cppreference.com/w/cpp/types/numeric_limits  ","wordCount":"507","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://64.github.io/cpp-faq/fixed-width-integers/"},"publisher":{"@type":"Organization","name":"C++ FAQ","logo":{"@type":"ImageObject","url":"https://64.github.io/cpp-faq/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://64.github.io/cpp-faq accesskey=h title="C++ FAQ (Alt + H)">C++ FAQ</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>What are fixed-width integers?</h1><div class=post-meta><ul class=post-tags><li><a href=https://64.github.io/cpp-faq/tags/beginner/>beginner</a></li></ul></div></header><div class=post-content><p>Fixed-width integers are integral types with a fixed number of bits. The C++ standard only specifies a minimum byte count for types such as <code>short</code>, <code>int</code> and <code>long</code>. Fixed-width integers guarantee a specific size, but their use can have an impact on portability, since they are not supported by all platforms.</p><h2 id=fixed-width-integer-types>Fixed-width integer types<a hidden class=anchor aria-hidden=true href=#fixed-width-integer-types>#</a></h2><p>These can be used by including <code>&lt;cstdint></code>. The <code>intX_t</code> types are signed integers with exactly <code>X</code> bits. <code>uintX_t</code> types are the same, but unsigned.</p><ul><li><code>std::int8_t</code> / <code>std::uint8_t</code> (1 byte)<ul><li><strong>Note:</strong> These are treated as characters on most systems. When printing variables of this type, they might show up as their ASCII equivalent.</li></ul></li><li><code>std::int16_t</code> / <code>std::uint16_t</code> (2 bytes)</li><li><code>std::int32_t</code> / <code>std::uint32_t</code> (4 bytes)</li><li><code>std::int64_t</code> / <code>std::uint64_t</code> (8 bytes)</li></ul><p><strong>Note:</strong> The number of bytes is the number of bits in the type, divided by the number of bits in one byte. On architectures where bits per byte != 8, some or even all of these types may not be defined.</p><h3 id=the-more-portable-alternative>The more portable alternative<a hidden class=anchor aria-hidden=true href=#the-more-portable-alternative>#</a></h3><p>To optimize integral types for faster access times and to ensure portability with more exotic architectures, the following types allow the compiler to choose a suitable integer size, while also ensuring a minimum number of bits.</p><p>For every <code>std::(u)intX_t</code> type there is a <code>std::(u)int_leastX_t</code> that represents the smallest integral type with at least X bits. These optimize for memory.</p><p>Likewise, there are types that optimize for speed: <code>std::(u)int_fastX_t</code> (the fastest integral type with at least X bits).</p><h2 id=fixed-width-integer-range>Fixed-width integer range<a hidden class=anchor aria-hidden=true href=#fixed-width-integer-range>#</a></h2><p>Unsigned integers with X bits range from 0 to 2X - 1. Signed integers with X bits typically range from -2X-1 to 2X-1 - 1, assuming two&rsquo;s complement representation.</p><p>Accurate, platform-specific ranges can also be found in <code>&lt;cstdint></code>:</p><ul><li><code>INTX_MIN</code> / <code>INTX_MAX</code> (minimum and maximum values for <code>std::intX_t</code> and <code>std::uintX_t</code>)</li><li><code>INT_LEASTX_MIN</code> / <code>INT_LEASTX_MAX</code> (minimum and maximum values for <code>std::int_leastX_t</code> and <code>std::uint_leastX_t</code>)</li><li><code>INT_FASTX_MIN</code> / <code>INT_FASTX_MAX</code> (minimum and maximum values for <code>std::int_fastX_t</code> and <code>std::uint_fastX_t</code>)</li></ul><p>In C++, the standardized way of getting the limits of various numeric types is the class template <code>std::numeric_limits</code> defined in <code>&lt;limits></code>:</p><ul><li><code>std::numeric_limits&lt;T>.min()</code> - minimum value for an integer of type T</li><li><code>std::numeric_limits&lt;T>.max()</code> - maximum value for an integer of type T</li></ul><h2 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdint&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;climits&gt; // for CHAR_BIT</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#75715e>// 16-bit (2-byte) integer
</span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span><span style=color:#66d9ef>uint16_t</span> year <span style=color:#f92672>=</span> <span style=color:#ae81ff>1984</span>;
  
    <span style=color:#75715e>// Check size in bytes, will usually be 2
</span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> year <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>sizeof</span>(year) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; bytes&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
  
    <span style=color:#75715e>// Multiply by CHAR_BIT (number of bits in one byte) to get size in bits
</span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Size of fastest integer with at least 16 bits: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> (CHAR_BIT <span style=color:#f92672>*</span> <span style=color:#66d9ef>sizeof</span>(std<span style=color:#f92672>::</span><span style=color:#66d9ef>int_fast16_t</span>)) <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Maximum value: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> INT_FAST16_MAX <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
  
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>Compiling and running the above program with <code>gcc</code> on a 64-bit Intel architecture produces the following result:</p><pre><code>1984: 2 bytes
Size of fastest integer with at least 16 bits: 64
Maximum value: 9223372036854775807
</code></pre><p>The <code>std::uint16_t</code> variable is 2 bytes wide, as expected. The compiler decided that the fastest integral type with at least 16 bits is the 64-bit integer on this architecture.</p><h3 id=see-also>See Also<a hidden class=anchor aria-hidden=true href=#see-also>#</a></h3><ul><li><a href=https://en.cppreference.com/w/cpp/types/integer>https://en.cppreference.com/w/cpp/types/integer</a></li><li><a href=https://en.cppreference.com/w/cpp/types/numeric_limits>https://en.cppreference.com/w/cpp/types/numeric_limits</a></li></ul></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://64.github.io/cpp-faq>C++ FAQ</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/cpp-faq/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>