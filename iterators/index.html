<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>What is an iterator? | C++ FAQ</title><meta name=keywords content="c++,c++11"><meta name=description content="Iterators provide a unified API for accessing different containers. On the surface, they work similar to pointers:
std::vector<int> vec { 1, 2, 3 }; auto it = vec.begin(); // gives us an iterator which points to '1' it++; // start now points to '2' it++; // start now points to '3'  std::cout << *it << '\n'; // prints '3' TODO
Noncontiguous containers (std::list): linked list isn&rsquo;t a contiguous sequence, so it&rsquo;s impossible to relay on pointers for iteration instead you should provide an iterator that performs the same arithmetic operations as a pointer would do."><meta name=author content><link rel=canonical href=https://64.github.io/cpp-faq/iterators/><link href=/cpp-faq/assets/css/stylesheet.min.746a86b58bb2b052b5e4df8216510494f04f81e62c08d626150c26c69ca929da.css integrity="sha256-dGqGtYuysFK15N+CFlEElPBPgeYsCNYmFQwmxpypKdo=" rel="preload stylesheet" as=style><link rel=icon href=https://64.github.io/cpp-faq/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://64.github.io/cpp-faq/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://64.github.io/cpp-faq/favicon-32x32.png><link rel=apple-touch-icon href=https://64.github.io/cpp-faq/apple-touch-icon.png><link rel=mask-icon href=https://64.github.io/cpp-faq/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><meta property="og:title" content="What is an iterator?"><meta property="og:description" content="Iterators provide a unified API for accessing different containers. On the surface, they work similar to pointers:
std::vector<int> vec { 1, 2, 3 }; auto it = vec.begin(); // gives us an iterator which points to '1' it++; // start now points to '2' it++; // start now points to '3'  std::cout << *it << '\n'; // prints '3' TODO
Noncontiguous containers (std::list): linked list isn&rsquo;t a contiguous sequence, so it&rsquo;s impossible to relay on pointers for iteration instead you should provide an iterator that performs the same arithmetic operations as a pointer would do."><meta property="og:type" content="article"><meta property="og:url" content="https://64.github.io/cpp-faq/iterators/"><meta property="article:published_time" content="2021-03-26T16:37:10+00:00"><meta property="article:modified_time" content="2021-03-26T16:37:10+00:00"><meta property="og:site_name" content="C++ FAQ"><meta name=twitter:card content="summary"><meta name=twitter:title content="What is an iterator?"><meta name=twitter:description content="Iterators provide a unified API for accessing different containers. On the surface, they work similar to pointers:
std::vector<int> vec { 1, 2, 3 }; auto it = vec.begin(); // gives us an iterator which points to '1' it++; // start now points to '2' it++; // start now points to '3'  std::cout << *it << '\n'; // prints '3' TODO
Noncontiguous containers (std::list): linked list isn&rsquo;t a contiguous sequence, so it&rsquo;s impossible to relay on pointers for iteration instead you should provide an iterator that performs the same arithmetic operations as a pointer would do."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Faqs","item":"https://64.github.io/cpp-faq/faq/"},{"@type":"ListItem","position":3,"name":"What is an iterator?","item":"https://64.github.io/cpp-faq/iterators/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"What is an iterator?","name":"What is an iterator?","description":"Iterators provide a unified API for accessing different containers. On the surface, they work similar to pointers:\nstd::vector\u0026amp;lt;int\u0026amp;gt; vec { 1, 2, 3 }; auto it = vec.begin(); // …","keywords":["c++","c++11"],"articleBody":"Iterators provide a unified API for accessing different containers. On the surface, they work similar to pointers:\nstd::vectorint vec { 1, 2, 3 }; auto it = vec.begin(); // gives us an iterator which points to '1' it++; // start now points to '2' it++; // start now points to '3'  std::cout  *it  '\\n'; // prints '3' TODO\nNoncontiguous containers (std::list): linked list isn’t a contiguous sequence, so it’s impossible to relay on pointers for iteration instead you should provide an iterator that performs the same arithmetic operations as a pointer would do.\nint main() { std::listint mlist{7, 4, 5, 8, 9}; for(auto it = mlist.begin(); it != mlist.end(); ++it) { std::cout  *it  '\\n'; } } Algorithms the ‘algorithm’ header has a niche collection of useful algorithms, however these algorithms doesn’t apply on all of the iterator categories i.e (std::sort):\nint main() { std::listint my_list{6, 5, 4, 3, 8, 9}; std::vectorint my_vec{6, 5, 4, 3, 8, 9}; std::sort(my_vec.begin(), my_vec.end()); std::sort(my_list.begin(), my_list.end()); } the above code works fine for std::vector std::list that’s due to std::sort’s iterator requirements, since it uses specific arithmetic operations that are supported by certain iterator (Random Access Iterator).\ninterface of an iterator (i.e Bidirectional Iterator): *iterator: returns the stored value pointed by the iterator.\niterator++, ++iterator: increments the pointer.\niterator–, –iterator: decrements the pointers.\niterator !=/== iterator: compare the pointers held by both operands. Useful for indicating where a range starts and ends.\nnote: An iterator itself mustn’t have begin/end functions as it’s container’s responsibility to handle these functions.\ncategories of an iterator: there are 5 iterators in C++ defined by the standard as:\n  input iterator: input iterator is a single direction iterator and read only means you can only increment it and read from it. It’s one of the simplest iterators. Usually used for reading from input streams like files in read only mode, stdin.\n  output iterator: same as input iterator, output iterator is a single direction iterator, but can only used for writing to a stream.\n  forward iterator: forward iterator is a single direction iterator that can be used for both reading and writing, usually used in containers like std::forward_list.\n  bidirectional iterator: bidirectional iterator is just a forward iterator that can be moved to both direction incrementing, decrementing\n  random access iterator: random access iterator is a bidirectional iterator that can be moved to any direction means if you want to access to the Nth element of a sequence you can just do auto Nth_Value = container.begin() + N; unlike previous iterators where you should increment N times. Random access iterator is the hardest and yet most powerful iterator since it supports all of the previously mentioned iterators.\n  contiguous iterator (since C++20): contiguous iterator is a random access iterator where the elements it points to are contiguously ordered in the memory\n  conclusion: In brief Contiguous Iterator is a superset of a Random Access Iterator which is a superset of a Bidirectional Iterator a Forward Iterator and a input/output iterator.\niterator vs pointer: As discussed earlier an iterator is just an abstraction of a pointer, but with more consistency (i.e we can’t just use pointers for iterating over a linked list as it’s not contiguous and lead to UB, but we instead create a custom iterator and move the current stored pointer to some node to the next node if the location has changed). pointer:\nint main() { const int N = 2; int arr[] = {6, 8, 5, 6}; auto first = arr; // first points to the first element of arr: 6  first++; // can be incremented  ++first; first--; // decremented  --first; use(*first); // deferenceced  use(first[N]); // same as use(*(first + N))  first += N; // re-assigned to point to another location  first -= N; } RAI (Random Access Iterator):\nint main() { const int N = 2; std::vectorint vec{6, 8, 5, 6}; auto first = vec.begin(); first++; ++first; first--; --first; use(*first); use(first[N]); first += N; first -= N; } ","wordCount":"659","inLanguage":"en","datePublished":"2021-03-26T16:37:10Z","dateModified":"2021-03-26T16:37:10Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://64.github.io/cpp-faq/iterators/"},"publisher":{"@type":"Organization","name":"C++ FAQ","logo":{"@type":"ImageObject","url":"https://64.github.io/cpp-faq/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://64.github.io/cpp-faq accesskey=h title="C++ FAQ (Alt + H)">C++ FAQ</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>What is an iterator?</h1><div class=post-meta><ul class=post-tags><li><a href=https://64.github.io/cpp-faq/tags/c++/>c++</a></li><li><a href=https://64.github.io/cpp-faq/tags/c++11/>c++11</a></li></ul></div></header><div class=post-content><p>Iterators provide a unified API for accessing different containers. On the surface, they work similar to pointers:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> vec { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span> };

<span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> vec.begin(); <span style=color:#75715e>// gives us an iterator which points to &#39;1&#39;
</span><span style=color:#75715e></span>it<span style=color:#f92672>++</span>; <span style=color:#75715e>// start now points to &#39;2&#39;
</span><span style=color:#75715e></span>it<span style=color:#f92672>++</span>; <span style=color:#75715e>// start now points to &#39;3&#39;
</span><span style=color:#75715e></span>
std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>it <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>; <span style=color:#75715e>// prints &#39;3&#39;
</span></code></pre></div><p>TODO</p><h5 id=noncontiguous-containers-stdlist>Noncontiguous containers (std::list):<a hidden class=anchor aria-hidden=true href=#noncontiguous-containers-stdlist>#</a></h5><p>linked list isn&rsquo;t a contiguous sequence, so it&rsquo;s impossible to relay on pointers for iteration instead you should provide an iterator that performs the same arithmetic operations as a pointer would do.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    std<span style=color:#f92672>::</span>list<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> mlist{<span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>};
    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> mlist.begin(); it <span style=color:#f92672>!=</span> mlist.end(); <span style=color:#f92672>++</span>it) {
        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#f92672>*</span>it <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
    }
}
</code></pre></div><h4 id=algorithms>Algorithms<a hidden class=anchor aria-hidden=true href=#algorithms>#</a></h4><p>the &lsquo;algorithm&rsquo; header has a niche collection of useful algorithms, however these algorithms doesn&rsquo;t apply on all of the iterator categories i.e (std::sort):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    std<span style=color:#f92672>::</span>list<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> my_list{<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>};
    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> my_vec{<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>};
    std<span style=color:#f92672>::</span>sort(my_vec.begin(), my_vec.end());
    std<span style=color:#f92672>::</span>sort(my_list.begin(), my_list.end());
}
</code></pre></div><p>the above code works fine for <a href=https://en.cppreference.com/w/cpp/container/vector>std::vector</a> <a href=https://en.cppreference.com/w/cpp/container/list>std::list</a> that&rsquo;s due to <a href=https://en.cppreference.com/w/cpp/algorithm/sort>std::sort</a>&rsquo;s iterator requirements, since it uses specific arithmetic operations that are supported by certain iterator (Random Access Iterator).</p><h3 id=interface-of-an-iterator-ie-bidirectional-iterator>interface of an iterator (i.e Bidirectional Iterator):<a hidden class=anchor aria-hidden=true href=#interface-of-an-iterator-ie-bidirectional-iterator>#</a></h3><p>*iterator: returns the stored value pointed by the iterator.</p><p>iterator++, ++iterator: increments the pointer.</p><p>iterator&ndash;, &ndash;iterator: decrements the pointers.</p><p>iterator !=/== iterator: compare the pointers held by both operands. Useful for indicating where a range starts and ends.</p><h4 id=note>note:<a hidden class=anchor aria-hidden=true href=#note>#</a></h4><p>An iterator itself mustn&rsquo;t have begin/end functions as it&rsquo;s container&rsquo;s responsibility to handle these functions.</p><h3 id=categories-of-an-iterator>categories of an iterator:<a hidden class=anchor aria-hidden=true href=#categories-of-an-iterator>#</a></h3><p>there are 5 iterators in C++ defined by the standard as:</p><ul><li><p><a href=https://en.cppreference.com/w/cpp/named_req/InputIterator>input iterator</a>:
input iterator is a single direction iterator and read only means you can only increment it and read from it. It&rsquo;s one of the simplest iterators. Usually used for reading from input streams like files in read only mode, stdin.</p></li><li><p><a href=https://en.cppreference.com/w/cpp/named_req/OutputIterator>output iterator</a>:
same as input iterator, output iterator is a single direction iterator, but can only used for writing to a stream.</p></li><li><p><a href=https://en.cppreference.com/w/cpp/named_req/ForwardIterator>forward iterator</a>:
forward iterator is a single direction iterator that can be used for both reading and writing, usually used in containers like <a href=https://en.cppreference.com/w/cpp/container/forward_list>std::forward_list</a>.</p></li><li><p><a href=https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator>bidirectional iterator</a>:
bidirectional iterator is just a forward iterator that can be moved to both direction incrementing, decrementing</p></li><li><p><a href=https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator>random access iterator</a>:
random access iterator is a bidirectional iterator that can be moved to any direction means if you want to access to the Nth element of a sequence you can just do <code>auto Nth_Value = container.begin() + N;</code> unlike previous iterators where you should increment N times. Random access iterator is the hardest and yet most powerful iterator since it supports all of the previously mentioned iterators.</p></li><li><p><a href=https://en.cppreference.com/w/cpp/named_req/ContiguousIterator>contiguous iterator (since C++20)</a>:
contiguous iterator is a random access iterator where the elements it points to are contiguously ordered in the memory</p></li></ul><h4 id=conclusion>conclusion:<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h4><p>In brief Contiguous Iterator is a superset of a Random Access Iterator which is a superset of a Bidirectional Iterator a Forward Iterator and a input/output iterator.</p><h3 id=iterator-vs-pointer>iterator vs pointer:<a hidden class=anchor aria-hidden=true href=#iterator-vs-pointer>#</a></h3><p>As discussed earlier an iterator is just an abstraction of a pointer, but with more consistency (i.e we can&rsquo;t just use pointers for iterating over a linked list as it&rsquo;s not contiguous and lead to UB, but we instead create a custom iterator and move the current stored pointer to some node to the next node if the location has changed).
pointer:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
    <span style=color:#66d9ef>int</span> arr[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>};
    <span style=color:#66d9ef>auto</span> first <span style=color:#f92672>=</span> arr; <span style=color:#75715e>// first points to the first element of arr: 6
</span><span style=color:#75715e></span>    first<span style=color:#f92672>++</span>; <span style=color:#75715e>// can be incremented
</span><span style=color:#75715e></span>    <span style=color:#f92672>++</span>first;
    first<span style=color:#f92672>--</span>; <span style=color:#75715e>// decremented
</span><span style=color:#75715e></span>    <span style=color:#f92672>--</span>first;
    use(<span style=color:#f92672>*</span>first); <span style=color:#75715e>// deferenceced
</span><span style=color:#75715e></span>    use(first[N]); <span style=color:#75715e>// same as use(*(first + N))
</span><span style=color:#75715e></span>    first <span style=color:#f92672>+=</span> N; <span style=color:#75715e>// re-assigned to point to another location  
</span><span style=color:#75715e></span>    first <span style=color:#f92672>-=</span> N;
    
}
</code></pre></div><p>RAI (Random Access Iterator):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> N <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> vec{<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>};
    <span style=color:#66d9ef>auto</span> first <span style=color:#f92672>=</span> vec.begin();
    first<span style=color:#f92672>++</span>;
    <span style=color:#f92672>++</span>first;
    first<span style=color:#f92672>--</span>;
    <span style=color:#f92672>--</span>first;
    use(<span style=color:#f92672>*</span>first);
    use(first[N]);
    first <span style=color:#f92672>+=</span> N;
    first <span style=color:#f92672>-=</span> N;
}
</code></pre></div></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://64.github.io/cpp-faq>C++ FAQ</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/cpp-faq/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>