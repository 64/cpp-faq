[{"content":"Undefined Behaviour (also known as UB) occurs when you violate certain language rules. These rules include (but are not limited to): dereferencing a nullptr, signed integer overflow, accessing through a dangling reference, or accessing through an unaligned pointer.\nWhen undefined behaviour occurs, the C and C++ standards do not place any restrictions on what your program might do. In other words, your program may crash, or continue execution, or call some seemingly unrelated piece of code, or print 42 and open xkcd in your web browser. In practice, you may be able to reason about how your compiler will respond to UB, and in some cases compilers will guarantee that certain operations are well-defined, but for maximum portability you should aim to keep your programs UB-free.\nExamples of UB int x; std::cout \u0026lt;\u0026lt; x; // UB: x was used before being initialized  int y = 0; std::cout \u0026lt;\u0026lt; y; // OK int arrayA[10]; for(int x : arrayA) std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; // UB: array elements are uninitialized  int arrayB[10] = {}; for(int x: arrayB) std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; // OK Avoiding UB Undefined behaviour can be difficult to diagnose. Always compile with warnings enabled, but note that compilers can\u0026rsquo;t detect all problems at compile time. Tools like ASan, UBSAN and Valgrind perform checks on your code at runtime and are good at catching invalid memory accesses, so are recommended for use during development.\n","permalink":"https://64.github.io/cpp-faq/ub/","summary":"Undefined Behaviour (also known as UB) occurs when you violate certain language rules. These rules include (but are not limited to): dereferencing a nullptr, signed integer overflow, accessing through a dangling reference, or accessing through an unaligned pointer.\nWhen undefined behaviour occurs, the C and C++ standards do not place any restrictions on what your program might do. In other words, your program may crash, or continue execution, or call some seemingly unrelated piece of code, or print 42 and open xkcd in your web browser.","title":"What is 'Undefined Behaviour'?"},{"content":"TODO\n","permalink":"https://64.github.io/cpp-faq/about-this-site/","summary":"TODO","title":"About this site"},{"content":"For gcc and clang users Add -Wall -Wextra to your compilation flags, enable -Werror so your compiler will treat warnings as errors, also you may need to enable -pedantic to disable gnu extensions\n(Note that, contrary to what the name -Wall may imply, this does not enable all warnings, but it does enable most of the important ones.)\nFor Visual Studio users Unlike gcc and clang, Visual Studio does enable some warnings by default. To set the warning level to something different, Consult Microsoft\u0026rsquo;s documentation here.\n","permalink":"https://64.github.io/cpp-faq/how-do-i-enable-compiler-warnings/","summary":"For gcc and clang users Add -Wall -Wextra to your compilation flags, enable -Werror so your compiler will treat warnings as errors, also you may need to enable -pedantic to disable gnu extensions\n(Note that, contrary to what the name -Wall may imply, this does not enable all warnings, but it does enable most of the important ones.)\nFor Visual Studio users Unlike gcc and clang, Visual Studio does enable some warnings by default.","title":"How do I enable compiler warnings?"},{"content":"Consider this code:\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; int swap = 0; int main() { cout \u0026lt;\u0026lt; swap \u0026lt;\u0026lt; endl; // error: reference to \u0026#34;swap\u0026#34; is ambiguous  return 0; } There the compiler throws an error because swap is also a function inside the algorithm header. Compiler doesn\u0026rsquo;t know what to do in this case.\nSo using namespace is considered a bad practice because makes your code less clear, and in the example leads to name collision. If you really want to avoid writing std::, you can use a using-declaration inside a local scope:\n#include \u0026lt;iostream\u0026gt; int main() { using std::cout; // This will be valid only inside this function \tcout \u0026lt;\u0026lt; \u0026#34;Hello\u0026#34; \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } Generally, is always better to specify the namespace. If you want to know something more about this topic, I recommend watching this video: https://www.youtube.com/watch?v=4NYC-VU-svE\n","permalink":"https://64.github.io/cpp-faq/why-using-namespace-std-is-considered-bad-practice/","summary":"Consider this code:\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; int swap = 0; int main() { cout \u0026lt;\u0026lt; swap \u0026lt;\u0026lt; endl; // error: reference to \u0026#34;swap\u0026#34; is ambiguous  return 0; } There the compiler throws an error because swap is also a function inside the algorithm header. Compiler doesn\u0026rsquo;t know what to do in this case.\nSo using namespace is considered a bad practice because makes your code less clear, and in the example leads to name collision.","title":"Why using namespace std is considered bad practice?"}]