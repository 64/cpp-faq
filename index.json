[{"content":"TODO\n","permalink":"https://64.github.io/cpp-faq/meta/about/","summary":"TODO","title":"About this site"},{"content":"For gcc and clang users: Add -Wall -Wextra to your compilation flags.\nOther useful options include:\n -Werror: treats warnings as if they were errors -pedantic: generates warnings if you use any language extensions -Wno-x: disables warning x, e.g if the compiler gives you a -Wunused-variable warning, you can turn it off with -Wno-unused-variable  (Note that, contrary to what the name -Wall may imply, this does not enable all warnings, but it does enable most of the important ones.)\nFor Visual Studio users: Unlike gcc and clang, Visual Studio does enable some warnings by default. To set the warning level to something different, Consult Microsoft\u0026rsquo;s documentation here.\n","permalink":"https://64.github.io/cpp-faq/enable-warnings/","summary":"For gcc and clang users: Add -Wall -Wextra to your compilation flags.\nOther useful options include:\n -Werror: treats warnings as if they were errors -pedantic: generates warnings if you use any language extensions -Wno-x: disables warning x, e.g if the compiler gives you a -Wunused-variable warning, you can turn it off with -Wno-unused-variable  (Note that, contrary to what the name -Wall may imply, this does not enable all warnings, but it does enable most of the important ones.","title":"How do I enable compiler warnings?"},{"content":"Undefined Behaviour (also known as UB) occurs when you violate certain language rules. These rules include (but are not limited to): dereferencing a null pointer, signed integer overflow, accessing through a dangling reference, or accessing through an unaligned pointer.\nWhen undefined behaviour occurs, the C and C++ standards do not place any restrictions on what your program might do. In other words, your program may crash, or continue execution, or call some seemingly unrelated piece of code, or print 42 and open xkcd in your web browser. In practice, you may be able to reason about how your compiler will respond to UB, and in some cases compilers will guarantee that certain operations are well-defined, but for maximum portability you should aim to keep your programs UB-free.\nExamples of UB int x; std::cout \u0026lt;\u0026lt; x; // UB: x was used before being initialized  int *y = nullptr; *y = 5; // UB: dereferencing null pointer  int arrayA[10]; for(int z : arrayA) std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; // UB: array elements used when uninitialized  int *w = new int; delete w; *w = 5; // UB: object used after being destroyed Avoiding UB Undefined behaviour can be difficult to diagnose. Always compile with warnings enabled, but note that compilers can\u0026rsquo;t detect all problems at compile time. Tools like ASan, UBSan and Valgrind perform checks on your code at runtime and are good at catching invalid memory accesses, so are recommended for use during development.\nFor gcc and clang users, we recommend using -Wall -Wextra -g -fsanitize=address,undefined in your compilation flags during development. This enables compiler warnings, ASan, UBSan (and debugging symbols for nicer sanitizer error messages).\nSee Also  https://en.cppreference.com/w/c/language/behavior  ","permalink":"https://64.github.io/cpp-faq/undefined-behaviour/","summary":"Undefined Behaviour (also known as UB) occurs when you violate certain language rules. These rules include (but are not limited to): dereferencing a null pointer, signed integer overflow, accessing through a dangling reference, or accessing through an unaligned pointer.\nWhen undefined behaviour occurs, the C and C++ standards do not place any restrictions on what your program might do. In other words, your program may crash, or continue execution, or call some seemingly unrelated piece of code, or print 42 and open xkcd in your web browser.","title":"What is 'Undefined Behaviour'?"},{"content":"Consider this code:\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; int swap = 0; int main() { cout \u0026lt;\u0026lt; swap \u0026lt;\u0026lt; endl; // ERROR: reference to \u0026#34;swap\u0026#34; is ambiguous } Here, the compiler throws an error because it doesn\u0026rsquo;t know whether you refer to your swap global variable, or the std::swap function inside the \u0026lt;algorithm\u0026gt; header.\nThat is to say, using namespace is considered bad practice because it leads to name collisions, and it also makes your code less clear. If you absolutely must, you can use a using-declaration inside a local scope:\n#include \u0026lt;iostream\u0026gt; int main() { using std::cout; // This only affects the current function  cout \u0026lt;\u0026lt; \u0026#34;Hello\u0026#34; \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } Generally speaking, it is better to specify the namespace.\nSee also  https://isocpp.org/wiki/faq/coding-standards#using-namespace-std  ","permalink":"https://64.github.io/cpp-faq/using-namespace-std/","summary":"Consider this code:\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; int swap = 0; int main() { cout \u0026lt;\u0026lt; swap \u0026lt;\u0026lt; endl; // ERROR: reference to \u0026#34;swap\u0026#34; is ambiguous } Here, the compiler throws an error because it doesn\u0026rsquo;t know whether you refer to your swap global variable, or the std::swap function inside the \u0026lt;algorithm\u0026gt; header.\nThat is to say, using namespace is considered bad practice because it leads to name collisions, and it also makes your code less clear.","title":"Why is `using namespace std` considered bad practice?"}]