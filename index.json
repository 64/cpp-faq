[{"content":"Iterators provide a unified API for accessing different containers. On the surface, they work similar to pointers:\nstd::vector\u0026lt;int\u0026gt; vec { 1, 2, 3 }; auto it = vec.begin(); // gives us an iterator which points to \u0026#39;1\u0026#39; it++; // start now points to \u0026#39;2\u0026#39; it++; // start now points to \u0026#39;3\u0026#39;  std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints \u0026#39;3\u0026#39; TODO\nNoncontiguous containers (std::list): linked list isn\u0026rsquo;t a contiguous sequence, so it\u0026rsquo;s impossible to relay on pointers for iteration instead you should provide an iterator that performs the same arithmetic operations as a pointer would do.\nint main() { std::list\u0026lt;int\u0026gt; mlist{7, 4, 5, 8, 9}; for(auto it = mlist.begin(); it != mlist.end(); ++it) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } Algorithms the \u0026lsquo;algorithm\u0026rsquo; header has a niche collection of useful algorithms, however these algorithms doesn\u0026rsquo;t apply on all of the iterator categories i.e (std::sort):\nint main() { std::list\u0026lt;int\u0026gt; my_list{6, 5, 4, 3, 8, 9}; std::vector\u0026lt;int\u0026gt; my_vec{6, 5, 4, 3, 8, 9}; std::sort(my_vec.begin(), my_vec.end()); std::sort(my_list.begin(), my_list.end()); } the above code works fine for std::vector std::list that\u0026rsquo;s due to std::sort\u0026rsquo;s iterator requirements, since it uses specific arithmetic operations that are supported by certain iterator (Random Access Iterator).\ninterface of an iterator (i.e Bidirectional Iterator): *iterator: returns the stored value pointed by the iterator.\niterator++, ++iterator: increments the pointer.\niterator\u0026ndash;, \u0026ndash;iterator: decrements the pointers.\niterator !=/== iterator: compare the pointers held by both operands. Useful for indicating where a range starts and ends.\nnote: An iterator itself mustn\u0026rsquo;t have begin/end functions as it\u0026rsquo;s container\u0026rsquo;s responsibility to handle these functions.\ncategories of an iterator: there are 5 iterators in C++ defined by the standard as:\n  input iterator: input iterator is a single direction iterator and read only means you can only increment it and read from it. It\u0026rsquo;s one of the simplest iterators. Usually used for reading from input streams like files in read only mode, stdin.\n  output iterator: same as input iterator, output iterator is a single direction iterator, but can only used for writing to a stream.\n  forward iterator: forward iterator is a single direction iterator that can be used for both reading and writing, usually used in containers like std::forward_list.\n  bidirectional iterator: bidirectional iterator is just a forward iterator that can be moved to both direction incrementing, decrementing\n  random access iterator: random access iterator is a bidirectional iterator that can be moved to any direction means if you want to access to the Nth element of a sequence you can just do auto Nth_Value = container.begin() + N; unlike previous iterators where you should increment N times. Random access iterator is the hardest and yet most powerful iterator since it supports all of the previously mentioned iterators.\n  contiguous iterator (since C++20): contiguous iterator is a random access iterator where the elements it points to are contiguously ordered in the memory\n  conclusion: In brief Contiguous Iterator is a superset of a Random Access Iterator which is a superset of a Bidirectional Iterator a Forward Iterator and a input/output iterator.\niterator vs pointer: As discussed earlier an iterator is just an abstraction of a pointer, but with more consistency (i.e we can\u0026rsquo;t just use pointers for iterating over a linked list as it\u0026rsquo;s not contiguous and lead to UB, but we instead create a custom iterator and move the current stored pointer to some node to the next node if the location has changed). pointer:\nint main() { const int N = 2; int arr[] = {6, 8, 5, 6}; auto first = arr; // first points to the first element of arr: 6  first++; // can be incremented  ++first; first--; // decremented  --first; use(*first); // deferenceced  use(first[N]); // same as use(*(first + N))  first += N; // re-assigned to point to another location  first -= N; } RAI (Random Access Iterator):\nint main() { const int N = 2; std::vector\u0026lt;int\u0026gt; vec{6, 8, 5, 6}; auto first = vec.begin(); first++; ++first; first--; --first; use(*first); use(first[N]); first += N; first -= N; } ","permalink":"https://64.github.io/cpp-faq/iterators/","summary":"Iterators provide a unified API for accessing different containers. On the surface, they work similar to pointers:\nstd::vector\u0026lt;int\u0026gt; vec { 1, 2, 3 }; auto it = vec.begin(); // gives us an iterator which points to \u0026#39;1\u0026#39; it++; // start now points to \u0026#39;2\u0026#39; it++; // start now points to \u0026#39;3\u0026#39;  std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints \u0026#39;3\u0026#39; TODO\nNoncontiguous containers (std::list): linked list isn\u0026rsquo;t a contiguous sequence, so it\u0026rsquo;s impossible to relay on pointers for iteration instead you should provide an iterator that performs the same arithmetic operations as a pointer would do.","title":"What is an iterator?"},{"content":"TODO\n","permalink":"https://64.github.io/cpp-faq/meta/about/","summary":"TODO","title":"About this site"},{"content":"For gcc and clang users: Add -Wall -Wextra to your compilation flags.\nOther useful options include:\n -Werror: treats warnings as if they were errors -pedantic: generates warnings if you use any language extensions -Wno-x: disables warning x, e.g if the compiler gives you a -Wunused-variable warning, you can turn it off with -Wno-unused-variable  (Note that, contrary to what the name -Wall may imply, this does not enable all warnings, but it does enable most of the important ones.)\nFor Visual Studio users: Unlike gcc and clang, Visual Studio does enable some warnings by default. To set the warning level to something different, Consult Microsoft\u0026rsquo;s documentation here.\n","permalink":"https://64.github.io/cpp-faq/enable-warnings/","summary":"For gcc and clang users: Add -Wall -Wextra to your compilation flags.\nOther useful options include:\n -Werror: treats warnings as if they were errors -pedantic: generates warnings if you use any language extensions -Wno-x: disables warning x, e.g if the compiler gives you a -Wunused-variable warning, you can turn it off with -Wno-unused-variable  (Note that, contrary to what the name -Wall may imply, this does not enable all warnings, but it does enable most of the important ones.","title":"How do I enable compiler warnings?"},{"content":"Unlike undefined behavior, unspecified and implementation-defined behavior occur all the time in a normal C++ program. Making use of unspecified/implementation-defined behavior is unavoidable, but relying on specific behavior can be fatal.\nThe C++ standard does not specify what happens in every scenario, so the implementation has the freedom to implement behavior, constants, macro definitions, and more in multiple possible ways.\nUnspecified Behavior unspecified by the standard is not necessary to document, but still valid. The range of possible behavior behavior can be predictable and is sometimes even specified explicitly by the C++ standard. However, in most cases, the exact behavior can not be predicted.\nCommon Examples The following things are unspecified (list not exhaustive):\n whether all string literals are distinct (they might have different addresses) the initial value of storage allocated by new (often zero when getting new memory from the OS) evaluation order of operands of some operators (for A + B, B might be evaluated before A) amount of time it takes for a thread to make progress (but eventual progress is guaranteed) whether references require any storage (they usually do, just like pointers)  Unspecified behavior can be as predictable as \u0026ldquo;we probably know what happens\u0026rdquo;, such as a reference requiring some storage when used as a class member. However, it can also be nonsensical to define, such as the initial value of storage allocated by new. The new operator usually uses std::malloc to allocate storage, but the initial value of std::malloc\u0026rsquo;s storage is indeterminate.\nFrom the C++20 standard:\n unspecified behavior behavior, for a well-formed program construct and correct data, that depends on the implementation\nNote: The implementation is not required to document which behavior occurs. [\u0026hellip;]\n See 3.31 [defns.unspecified]\nImplementation-Defined Implementation-defined is a lesser evil than unspecified, because the implementation details must be documented. Relying on implementation-defined behavior can still cause portability issues such as code working only on one operating system, but at least, these portability issues are known and predictable.\nCommon Examples The following things are implementation-defined (list not exhaustive):\n the exact size of fundamental types such as int and long definition of the NULL macro (possibly 0, ((void*)0), or nullptr) conversions between pointers and integers (reinterpret_cast\u0026lt;std::uintptr_t\u0026gt;(...)) nesting limit for #include directives choice of larger or smaller value for float literals (round up or down if necessary) operating systems on which implementation depends value of pow(0,0) (usually 1)  All of these details are documented somewhere, whether it is in standard library headers, manual pages of the OS, etc. Problems only arise when the developer relies on one particular implementation. A common example is assuming that long will be at least 64 bits in size, when actually, only 32 bits are guaranteed by the standard. Windows requires long to be 32 bits, while Unix-like operating systems use 64 bits.\nFrom the C++20 standard:\n implementation-defined behavior behavior, for a well-formed program construct and correct data, that depends on the implementation and that each implementation documents\n See 3.13 [defns.impl.defined]\nSee Also  https://en.cppreference.com/w/cpp/language/types#Data_models https://en.wikipedia.org/wiki/Unspecified_behavior https://timsong-cpp.github.io/cppwp/n4861/impldefindex  ","permalink":"https://64.github.io/cpp-faq/unspecified-impldefined/","summary":"Unlike undefined behavior, unspecified and implementation-defined behavior occur all the time in a normal C++ program. Making use of unspecified/implementation-defined behavior is unavoidable, but relying on specific behavior can be fatal.\nThe C++ standard does not specify what happens in every scenario, so the implementation has the freedom to implement behavior, constants, macro definitions, and more in multiple possible ways.\nUnspecified Behavior unspecified by the standard is not necessary to document, but still valid.","title":"What are 'Unspecified' and 'Implementation-Defined' behavior?"},{"content":"Undefined Behaviour (also known as UB) occurs when you violate certain language rules. These rules include (but are not limited to): dereferencing a null pointer, signed integer overflow, accessing through a dangling reference, or accessing through an unaligned pointer.\nWhen undefined behaviour occurs, the C and C++ standards do not place any restrictions on what your program might do. In other words, your program may crash, or continue execution, or call some seemingly unrelated piece of code, or print 42 and open xkcd in your web browser.\nIn practice, you may be able to reason about how your compiler will respond to UB, and in some cases compilers will guarantee that certain operations are well-defined, but for maximum portability you should aim to keep your programs UB-free.\nExamples of UB int x; std::cout \u0026lt;\u0026lt; x; // UB: x was used before being initialized  int *y = nullptr; *y = 5; // UB: dereferencing null pointer  int arrayA[10]; for(int z : arrayA) std::cout \u0026lt;\u0026lt; z \u0026lt;\u0026lt; \u0026#39; \u0026#39;; // UB: array elements used when uninitialized  int *w = new int; delete w; *w = 5; // UB: object used after being destroyed Avoiding UB Undefined behaviour can be difficult to diagnose. Always compile with warnings enabled, but note that compilers can\u0026rsquo;t detect all problems at compile time. Tools like ASan, UBSan and Valgrind perform checks on your code at runtime and are good at catching invalid memory accesses, so are recommended for use during development.\nFor gcc and clang users, we recommend using\n-Wall -Wextra -g -fsanitize=address,undefined in your compilation flags during development. This enables compiler warnings, ASan, UBSan (and debugging symbols for nicer sanitizer error messages).\nSee Also  https://en.cppreference.com/w/c/language/behavior  ","permalink":"https://64.github.io/cpp-faq/undefined-behaviour/","summary":"Undefined Behaviour (also known as UB) occurs when you violate certain language rules. These rules include (but are not limited to): dereferencing a null pointer, signed integer overflow, accessing through a dangling reference, or accessing through an unaligned pointer.\nWhen undefined behaviour occurs, the C and C++ standards do not place any restrictions on what your program might do. In other words, your program may crash, or continue execution, or call some seemingly unrelated piece of code, or print 42 and open xkcd in your web browser.","title":"What is 'Undefined Behaviour'?"},{"content":"When we call functions in C++, our arguments may need to undergo type conversions. For example, we can call a function that takes an int with a const int argument, which copies its value. For parameters which are passed by value, some of these conversions rules are called decay. They are called decay because in most cases, some type information is lost, such as the size of an array or the const qualifier in our example.\nArray-to-Pointer Conversion A commonly known form of decay is array-to-pointer conversion:\n// We seemingly accept an array by value as our parameter: void print_size(char arr[128]) { // warning: \u0026#39;sizeof\u0026#39; on array function parameter \u0026#39;arr\u0026#39;  // will return size of \u0026#39;char *\u0026#39; [-Wsizeof-array-argument]  std::cout \u0026lt;\u0026lt; sizeof(arr) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } Sample output: 8\nWe have attempted to specify that our print_size should accept an array with size 128 of char by value as its function parameter. However, arrays cannot be passed by value and instead decay to pointers. So from the compiler\u0026rsquo;s point of view, our function signature is equal to:\nvoid print_size(char *arr); Using sizeof with arrays that have decayed to a pointer is a common source of bugs, as in the above example, where we obtain the size of a pointer, which is less than the size of the entire array. Thankfully, GCC and clang warn us about this.\nFunction-to-Pointer conversion Another very similar form of decay is function-to-pointer conversion:\nvoid call(void callback(int), int x) { callback(x); } Here, our first function parameter appears to be another function callback, which takes an int and returns nothing. However, just as an array, the function callback decays to a pointer. It would be equivalent to write:\nvoid call(void (*callback)(int), int x) { callback(x); } The danger of misuse is not as great here; decay simply gives us a nicer syntax for accepting function pointers.\nDiscarding const/volatile qualifiers and removing references This form of decay is something that you have likely understood already by intuition. When we accept a type T as a parameter to our function by value, we don\u0026rsquo;t care whether the arguments were const, volatile, references, other values, etc. Inside of the function, we are simply using T.\nThis form of decay can be seen in the following examples:\nvoid use_int(int my_int) { /* ... */ } int main() { // Calling use_int with a literal of type int:  use_int(3); // Calling use_int with a const volatile int: This copies the value of x.  // const and volatile are discarded, so inside of use_int,  // we don\u0026#39;t care that the argument was const or volatile.  const volatile int x = 7; use_int(x); // Calling use_int with an int\u0026amp; copies the referenced value:  // Inside of use_int, we don\u0026#39;t see or care that the argument was a reference.  int y = 5; int \u0026amp;yref = y; use_int(y); } Using std::decay The documentation of the std::decay type trait lists all these decay conversions. std::decay can be used to simulate them and there is also a templated type alias std::decay_t for convenience. Here are a few examples:\n// no decay std::decay_t\u0026lt;int\u0026gt; -\u0026gt; int // discarding references std::decay_t\u0026lt;int\u0026amp;\u0026gt; -\u0026gt; int // discarding references and const qualifier std::decay_t\u0026lt;const int\u0026amp;\u0026gt; -\u0026gt; int // discarding volatile std::decay_t\u0026lt;volatile int\u0026gt; -\u0026gt; int // array-to-pointer std::decay_t\u0026lt;int[8]\u0026gt; -\u0026gt; int* // array-to-pointer, and also discarding the reference std::decay_t\u0026lt;int(\u0026amp;)[8]\u0026gt; -\u0026gt; int* // function-to-pointer std::decay_t\u0026lt;int(int)\u0026gt; -\u0026gt; int(*)(int) ","permalink":"https://64.github.io/cpp-faq/decay/","summary":"When we call functions in C++, our arguments may need to undergo type conversions. For example, we can call a function that takes an int with a const int argument, which copies its value. For parameters which are passed by value, some of these conversions rules are called decay. They are called decay because in most cases, some type information is lost, such as the size of an array or the const qualifier in our example.","title":"What is decay and array-to-pointer conversion?"},{"content":"Consider this code:\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; int swap = 0; int main() { cout \u0026lt;\u0026lt; swap \u0026lt;\u0026lt; endl; // ERROR: reference to \u0026#34;swap\u0026#34; is ambiguous } Here, the compiler throws an error because it doesn\u0026rsquo;t know whether you refer to your swap global variable, or the std::swap function inside the \u0026lt;algorithm\u0026gt; header.\nThat is to say, using namespace is considered bad practice because it leads to name collisions, and it also makes your code less clear. If you absolutely must, you can use a using-declaration inside a local scope:\n#include \u0026lt;iostream\u0026gt; int main() { using std::cout; // This only affects the current function  cout \u0026lt;\u0026lt; \u0026#34;Hello\u0026#34; \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } Generally speaking, it is better to specify the namespace.\nSee also  https://isocpp.org/wiki/faq/coding-standards#using-namespace-std  ","permalink":"https://64.github.io/cpp-faq/using-namespace-std/","summary":"Consider this code:\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; int swap = 0; int main() { cout \u0026lt;\u0026lt; swap \u0026lt;\u0026lt; endl; // ERROR: reference to \u0026#34;swap\u0026#34; is ambiguous } Here, the compiler throws an error because it doesn\u0026rsquo;t know whether you refer to your swap global variable, or the std::swap function inside the \u0026lt;algorithm\u0026gt; header.\nThat is to say, using namespace is considered bad practice because it leads to name collisions, and it also makes your code less clear.","title":"Why is `using namespace std` considered bad practice?"}]