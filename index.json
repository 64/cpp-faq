[{"content":"Iterators provide a unified API for accessing different containers. On the surface, they work similar to pointers:\nstd::vector\u0026lt;int\u0026gt; vec { 1, 2, 3 }; auto it = vec.begin(); // gives us an iterator which points to \u0026#39;1\u0026#39; it++; // start now points to \u0026#39;2\u0026#39; it++; // start now points to \u0026#39;3\u0026#39;  std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints \u0026#39;3\u0026#39; TODO\nNoncontiguous containers (std::list): linked list isn\u0026rsquo;t a contiguous sequence, so it\u0026rsquo;s impossible to relay on pointers for iteration instead you should provide an iterator that performs the same arithmetic operations as a pointer would do.\nint main() { std::list\u0026lt;int\u0026gt; mlist{7, 4, 5, 8, 9}; for(auto it = mlist.begin(); it != mlist.end(); ++it) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } Algorithms the \u0026lsquo;algorithm\u0026rsquo; header has a niche collection of useful algorithms, however these algorithms doesn\u0026rsquo;t apply on all of the iterator categories i.e (std::sort):\nint main() { std::list\u0026lt;int\u0026gt; my_list{6, 5, 4, 3, 8, 9}; std::vector\u0026lt;int\u0026gt; my_vec{6, 5, 4, 3, 8, 9}; std::sort(my_vec.begin(), my_vec.end()); std::sort(my_list.begin(), my_list.end()); } the above code works fine for std::vector std::list that\u0026rsquo;s due to std::sort\u0026rsquo;s iterator requirements, since it uses specific arithmetic operations that are supported by certain iterator (Random Access Iterator).\ninterface of an iterator (i.e Bidirectional Iterator): *iterator: returns the stored value pointed by the iterator.\niterator++, ++iterator: increments the pointer.\niterator\u0026ndash;, \u0026ndash;iterator: decrements the pointers.\niterator !=/== iterator: compare the pointers held by both operands. Useful for indicating where a range starts and ends.\nnote: An iterator itself mustn\u0026rsquo;t have begin/end functions as it\u0026rsquo;s container\u0026rsquo;s responsibility to handle these functions.\ncategories of an iterator: there are 5 iterators in C++ defined by the standard as:\n  input iterator: input iterator is a single direction iterator and read only means you can only increment it and read from it. It\u0026rsquo;s one of the simplest iterators. Usually used for reading from input streams like files in read only mode, stdin.\n  output iterator: same as input iterator, output iterator is a single direction iterator, but can only used for writing to a stream.\n  forward iterator: forward iterator is a single direction iterator that can be used for both reading and writing, usually used in containers like std::forward_list.\n  bidirectional iterator: bidirectional iterator is just a forward iterator that can be moved to both direction incrementing, decrementing\n  random access iterator: random access iterator is a bidirectional iterator that can be moved to any direction means if you want to access to the Nth element of a sequence you can just do auto Nth_Value = container.begin() + N; unlike previous iterators where you should increment N times. Random access iterator is the hardest and yet most powerful iterator since it supports all of the previously mentioned iterators.\n  contiguous iterator (since C++20): contiguous iterator is a random access iterator where the elements it points to are contiguously ordered in the memory\n  conclusion: In brief Contiguous Iterator is a superset of a Random Access Iterator which is a superset of a Bidirectional Iterator a Forward Iterator and a input/output iterator.\niterator vs pointer: As discussed earlier an iterator is just an abstraction of a pointer, but with more consistency (i.e we can\u0026rsquo;t just use pointers for iterating over a linked list as it\u0026rsquo;s not contiguous and lead to UB, but we instead create a custom iterator and move the current stored pointer to some node to the next node if the location has changed). pointer:\nint main() { const int N = 2; int arr[] = {6, 8, 5, 6}; auto first = arr; // first points to the first element of arr: 6  first++; // can be incremented  ++first; first--; // decremented  --first; use(*first); // deferenceced  use(first[N]); // same as use(*(first + N))  first += N; // re-assigned to point to another location  first -= N; } RAI (Random Access Iterator):\nint main() { const int N = 2; std::vector\u0026lt;int\u0026gt; vec{6, 8, 5, 6}; auto first = vec.begin(); first++; ++first; first--; --first; use(*first); use(first[N]); first += N; first -= N; } ","permalink":"https://64.github.io/cpp-faq/iterators/","summary":"Iterators provide a unified API for accessing different containers. On the surface, they work similar to pointers:\nstd::vector\u0026lt;int\u0026gt; vec { 1, 2, 3 }; auto it = vec.begin(); // gives us an iterator which points to \u0026#39;1\u0026#39; it++; // start now points to \u0026#39;2\u0026#39; it++; // start now points to \u0026#39;3\u0026#39;  std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // prints \u0026#39;3\u0026#39; TODO\nNoncontiguous containers (std::list): linked list isn\u0026rsquo;t a contiguous sequence, so it\u0026rsquo;s impossible to relay on pointers for iteration instead you should provide an iterator that performs the same arithmetic operations as a pointer would do.","title":"What is an iterator?"},{"content":"TODO\n","permalink":"https://64.github.io/cpp-faq/meta/about/","summary":"TODO","title":"About this site"},{"content":"For gcc and clang users: Add -Wall -Wextra to your compilation flags.\nOther useful options include:\n -Werror: treats warnings as if they were errors -pedantic: generates warnings if you use any language extensions -Wno-x: disables warning x, e.g if the compiler gives you a -Wunused-variable warning, you can turn it off with -Wno-unused-variable  (Note that, contrary to what the name -Wall may imply, this does not enable all warnings, but it does enable most of the important ones.)\nFor Visual Studio users: Unlike gcc and clang, Visual Studio does enable some warnings by default. To set the warning level to something different, Consult Microsoft\u0026rsquo;s documentation here.\n","permalink":"https://64.github.io/cpp-faq/enable-warnings/","summary":"For gcc and clang users: Add -Wall -Wextra to your compilation flags.\nOther useful options include:\n -Werror: treats warnings as if they were errors -pedantic: generates warnings if you use any language extensions -Wno-x: disables warning x, e.g if the compiler gives you a -Wunused-variable warning, you can turn it off with -Wno-unused-variable  (Note that, contrary to what the name -Wall may imply, this does not enable all warnings, but it does enable most of the important ones.","title":"How do I enable compiler warnings?"},{"content":"Undefined Behaviour (also known as UB) occurs when you violate certain language rules. These rules include (but are not limited to): dereferencing a null pointer, signed integer overflow, accessing through a dangling reference, or accessing through an unaligned pointer.\nWhen undefined behaviour occurs, the C and C++ standards do not place any restrictions on what your program might do. In other words, your program may crash, or continue execution, or call some seemingly unrelated piece of code, or print 42 and open xkcd in your web browser.\nIn practice, you may be able to reason about how your compiler will respond to UB, and in some cases compilers will guarantee that certain operations are well-defined, but for maximum portability you should aim to keep your programs UB-free.\nExamples of UB int x; std::cout \u0026lt;\u0026lt; x; // UB: x was used before being initialized  int *y = nullptr; *y = 5; // UB: dereferencing null pointer  int arrayA[10]; for(int z : arrayA) std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; // UB: array elements used when uninitialized  int *w = new int; delete w; *w = 5; // UB: object used after being destroyed Avoiding UB Undefined behaviour can be difficult to diagnose. Always compile with warnings enabled, but note that compilers can\u0026rsquo;t detect all problems at compile time. Tools like ASan, UBSan and Valgrind perform checks on your code at runtime and are good at catching invalid memory accesses, so are recommended for use during development.\nFor gcc and clang users, we recommend using\n-Wall -Wextra -g -fsanitize=address,undefined in your compilation flags during development. This enables compiler warnings, ASan, UBSan (and debugging symbols for nicer sanitizer error messages).\nSee Also  https://en.cppreference.com/w/c/language/behavior  ","permalink":"https://64.github.io/cpp-faq/undefined-behaviour/","summary":"Undefined Behaviour (also known as UB) occurs when you violate certain language rules. These rules include (but are not limited to): dereferencing a null pointer, signed integer overflow, accessing through a dangling reference, or accessing through an unaligned pointer.\nWhen undefined behaviour occurs, the C and C++ standards do not place any restrictions on what your program might do. In other words, your program may crash, or continue execution, or call some seemingly unrelated piece of code, or print 42 and open xkcd in your web browser.","title":"What is 'Undefined Behaviour'?"},{"content":"Consider this code:\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; int swap = 0; int main() { cout \u0026lt;\u0026lt; swap \u0026lt;\u0026lt; endl; // ERROR: reference to \u0026#34;swap\u0026#34; is ambiguous } Here, the compiler throws an error because it doesn\u0026rsquo;t know whether you refer to your swap global variable, or the std::swap function inside the \u0026lt;algorithm\u0026gt; header.\nThat is to say, using namespace is considered bad practice because it leads to name collisions, and it also makes your code less clear. If you absolutely must, you can use a using-declaration inside a local scope:\n#include \u0026lt;iostream\u0026gt; int main() { using std::cout; // This only affects the current function  cout \u0026lt;\u0026lt; \u0026#34;Hello\u0026#34; \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } Generally speaking, it is better to specify the namespace.\nSee also  https://isocpp.org/wiki/faq/coding-standards#using-namespace-std  ","permalink":"https://64.github.io/cpp-faq/using-namespace-std/","summary":"Consider this code:\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt; using namespace std; int swap = 0; int main() { cout \u0026lt;\u0026lt; swap \u0026lt;\u0026lt; endl; // ERROR: reference to \u0026#34;swap\u0026#34; is ambiguous } Here, the compiler throws an error because it doesn\u0026rsquo;t know whether you refer to your swap global variable, or the std::swap function inside the \u0026lt;algorithm\u0026gt; header.\nThat is to say, using namespace is considered bad practice because it leads to name collisions, and it also makes your code less clear.","title":"Why is `using namespace std` considered bad practice?"}]