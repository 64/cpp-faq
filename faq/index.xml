<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Faqs on C&#43;&#43; FAQ</title>
    <link>https://64.github.io/cpp-faq/faq/</link>
    <description>Recent content in Faqs on C&#43;&#43; FAQ</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 26 Mar 2021 16:37:10 +0000</lastBuildDate><atom:link href="https://64.github.io/cpp-faq/faq/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>What is an iterator?</title>
      <link>https://64.github.io/cpp-faq/iterators/</link>
      <pubDate>Fri, 26 Mar 2021 16:37:10 +0000</pubDate>
      
      <guid>https://64.github.io/cpp-faq/iterators/</guid>
      <description>Iterators provide a unified API for accessing different containers. On the surface, they work similar to pointers:
std::vector&amp;lt;int&amp;gt; vec { 1, 2, 3 }; auto it = vec.begin(); // gives us an iterator which points to &amp;#39;1&amp;#39; it++; // start now points to &amp;#39;2&amp;#39; it++; // start now points to &amp;#39;3&amp;#39;  std::cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; // prints &amp;#39;3&amp;#39; TODO
Noncontiguous containers (std::list): linked list isn&amp;rsquo;t a contiguous sequence, so it&amp;rsquo;s impossible to relay on pointers for iteration instead you should provide an iterator that performs the same arithmetic operations as a pointer would do.</description>
    </item>
    
    <item>
      <title>How do I enable compiler warnings?</title>
      <link>https://64.github.io/cpp-faq/enable-warnings/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://64.github.io/cpp-faq/enable-warnings/</guid>
      <description>For gcc and clang users: Add -Wall -Wextra to your compilation flags.
Other useful options include:
 -Werror: treats warnings as if they were errors -pedantic: generates warnings if you use any language extensions -Wno-x: disables warning x, e.g if the compiler gives you a -Wunused-variable warning, you can turn it off with -Wno-unused-variable  (Note that, contrary to what the name -Wall may imply, this does not enable all warnings, but it does enable most of the important ones.</description>
    </item>
    
    <item>
      <title>What are &#39;Unspecified&#39; and &#39;Implementation-Defined&#39; behavior?</title>
      <link>https://64.github.io/cpp-faq/unspecified-impldefined/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://64.github.io/cpp-faq/unspecified-impldefined/</guid>
      <description>Unlike undefined behavior, unspecified and implementation-defined behavior occur all the time in a normal C++ program. Making use of unspecified/implementation-defined behavior is unavoidable, but relying on specific behavior can be fatal.
The C++ standard does not specify what happens in every scenario, so the implementation has the freedom to implement behavior, constants, macro definitions, and more in multiple possible ways.
Unspecified Behavior unspecified by the standard is not necessary to document, but still valid.</description>
    </item>
    
    <item>
      <title>What is &#39;Undefined Behaviour&#39;?</title>
      <link>https://64.github.io/cpp-faq/undefined-behaviour/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://64.github.io/cpp-faq/undefined-behaviour/</guid>
      <description>Undefined Behaviour (also known as UB) occurs when you violate certain language rules. These rules include (but are not limited to): dereferencing a null pointer, signed integer overflow, accessing through a dangling reference, or accessing through an unaligned pointer.
When undefined behaviour occurs, the C and C++ standards do not place any restrictions on what your program might do. In other words, your program may crash, or continue execution, or call some seemingly unrelated piece of code, or print 42 and open xkcd in your web browser.</description>
    </item>
    
    <item>
      <title>What is decay and array-to-pointer conversion?</title>
      <link>https://64.github.io/cpp-faq/decay/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://64.github.io/cpp-faq/decay/</guid>
      <description>When we call functions in C++, our arguments may need to undergo type conversions. For example, we can call a function that takes an int with a const int argument, which copies its value. For parameters which are passed by value, some of these conversions rules are called decay. They are called decay because in most cases, some type information is lost, such as the size of an array or the const qualifier in our example.</description>
    </item>
    
    <item>
      <title>Why is `using namespace std` considered bad practice?</title>
      <link>https://64.github.io/cpp-faq/using-namespace-std/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://64.github.io/cpp-faq/using-namespace-std/</guid>
      <description>Consider this code:
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; int swap = 0; int main() { cout &amp;lt;&amp;lt; swap &amp;lt;&amp;lt; endl; // ERROR: reference to &amp;#34;swap&amp;#34; is ambiguous } Here, the compiler throws an error because it doesn&amp;rsquo;t know whether you refer to your swap global variable, or the std::swap function inside the &amp;lt;algorithm&amp;gt; header.
That is to say, using namespace is considered bad practice because it leads to name collisions, and it also makes your code less clear.</description>
    </item>
    
  </channel>
</rss>
