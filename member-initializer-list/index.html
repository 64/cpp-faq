<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>What is a 'Member Initalizer List' and why should I use it? | C++ FAQ</title><meta name=keywords content="beginner"><meta name=description content="Constructors in C++ are used to initialize the data members of a class. First, it&rsquo;s important to understand the terminology:
struct wrapper { int value; wrapper(int v) : value{v} { } }; Our class wrapper has a constructor, consisting of four parts:
 the class name wrapper the parameter list int v in parentheses the member initializer list value{v}, separated by a : from the parameter list the constructor body {}, which is empty in this case  In most other languages that have classes and constructors, the initialization simply takes place in the constructor body."><meta name=author content><link rel=canonical href=https://64.github.io/cpp-faq/member-initializer-list/><link href=/cpp-faq/assets/css/stylesheet.min.746a86b58bb2b052b5e4df8216510494f04f81e62c08d626150c26c69ca929da.css integrity="sha256-dGqGtYuysFK15N+CFlEElPBPgeYsCNYmFQwmxpypKdo=" rel="preload stylesheet" as=style><link rel=icon href=https://64.github.io/cpp-faq/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://64.github.io/cpp-faq/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://64.github.io/cpp-faq/favicon-32x32.png><link rel=apple-touch-icon href=https://64.github.io/cpp-faq/apple-touch-icon.png><link rel=mask-icon href=https://64.github.io/cpp-faq/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><meta property="og:title" content="What is a 'Member Initalizer List' and why should I use it?"><meta property="og:description" content="Constructors in C++ are used to initialize the data members of a class. First, it&rsquo;s important to understand the terminology:
struct wrapper { int value; wrapper(int v) : value{v} { } }; Our class wrapper has a constructor, consisting of four parts:
 the class name wrapper the parameter list int v in parentheses the member initializer list value{v}, separated by a : from the parameter list the constructor body {}, which is empty in this case  In most other languages that have classes and constructors, the initialization simply takes place in the constructor body."><meta property="og:type" content="article"><meta property="og:url" content="https://64.github.io/cpp-faq/member-initializer-list/"><meta property="og:site_name" content="C++ FAQ"><meta name=twitter:card content="summary"><meta name=twitter:title content="What is a 'Member Initalizer List' and why should I use it?"><meta name=twitter:description content="Constructors in C++ are used to initialize the data members of a class. First, it&rsquo;s important to understand the terminology:
struct wrapper { int value; wrapper(int v) : value{v} { } }; Our class wrapper has a constructor, consisting of four parts:
 the class name wrapper the parameter list int v in parentheses the member initializer list value{v}, separated by a : from the parameter list the constructor body {}, which is empty in this case  In most other languages that have classes and constructors, the initialization simply takes place in the constructor body."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Faqs","item":"https://64.github.io/cpp-faq/faq/"},{"@type":"ListItem","position":3,"name":"What is a 'Member Initalizer List' and why should I use it?","item":"https://64.github.io/cpp-faq/member-initializer-list/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"What is a 'Member Initalizer List' and why should I use it?","name":"What is a \u0027Member Initalizer List\u0027 and why should I use it?","description":"Constructors in C++ are used to initialize the data members of a class. First, it\u0026amp;rsquo;s important to understand the terminology:\nstruct wrapper { int value; wrapper(int v) : …","keywords":["beginner"],"articleBody":"Constructors in C++ are used to initialize the data members of a class. First, it’s important to understand the terminology:\nstruct wrapper { int value; wrapper(int v) : value{v} { } }; Our class wrapper has a constructor, consisting of four parts:\n the class name wrapper the parameter list int v in parentheses the member initializer list value{v}, separated by a : from the parameter list the constructor body {}, which is empty in this case  In most other languages that have classes and constructors, the initialization simply takes place in the constructor body. However, in C++, this is not possible as the constructor body can only be used for reassigning members after they have already been initialized.\nA Common Mistake: Trying to Initialize in the Constructor Body Consider the following example:\nstruct point { int x = 0; int y = 0; point(int x, int y) { this-x = x; this-y = y; } }; Here, when we call the constructor point(int,int), the members x and y are first initialized to zero using copy initialization. Afterwards, they get reassigned to the constructor parameters x and y respectively. This is not initializing the members to the parameters. It is reassigning them.\nIn such a trivial example, the difference isn’t noticeable. But if we use const members, reference members, array members, or any other non-assignable type, we receive compiler errors:\nstruct const_value { // error: uninitialized const member in 'const int' [-fpermissive]  // note: 'const int const_value::val' should be initialized  const int val; const_value(int val) { // error: assignment of read-only member 'const_value::val'  this-val = val; } }; In this case, we should be glad that we have received a compiler error, because there are also cases where our code compiles but performance gets degraded, unnoticeably. For example, if we have a std::string member, it may be inefficient to first initialize it to an empty string and then reassign it to another value.\nThe Right Way: Using a Member Initializer List To initialize our members, we should isntaed use a member initializer list and leave the constructor body empty:\nstruct const_point { const int x, y; const_point(int x, int y) : x{x}, y{y} {} }; This code compiles, unlike the previous example. We are taking the parameter x and y and initializing the members x and y to their values, respectively. Unlike in the previous, incorrect example of using this-x = to “initialize”, we can just use x as a parameter name without worrying about ambiguity with the members of our class.\nElements of the member initializer list are separated by a comma and follow the same syntax as initialization as variables. In this particular example with x{x}, y{y}, we are using list initialization to initialize the members. However, we could also use x() to value-initialize x to zero, or x(5) to direct-initialize x to a 5. Once again, we have the same syntax of initializing members in the member initializer list as for variables.\nThe constructor body can usually be left empty if we only initialize our members.\nAbout Initialization Order Sometimes the order of initialization is important. Initialization in C++ alwas takes place in the order of declaration of members inside the class, even if the member initializer list suggests otherwise. For example:\nstruct stringified_value { int value; std::string str; // warning: 'stringified_value::str' will be initialized after  // 'stringified_value::value'  // when initialized here [-Wreorder]  stringified_value(int v) : str{std::to_string(v)}, value{v} {} }; To avoid compiler warnings, we should always write our member initializer list in the order of declared members:\nstruct stringified_value { int value; std::string str; stringified_value(int v) : value{v}, str{std::to_string(v)} {} }; About Default Member Initializers Default member initializers are another correct way of initializing members. We could make our previous example more concise using them:\nstruct stringified_value { int value; // default member initializer here:  std::string str = std::to_string(value); stringified_value(int v) : value{v} {} }; In this example, value will first be initialized to v, then str will initialized to the stringified value. Remember, str is declared after value, so it’s always initialized after. Default member initializers are always executed for all constructors, unless they are overridden by a member initializer list. Say, we were to add a second constructor:\nstringified_value(int v, std::string s) : value{v}, str{std::move(s)} {} Now str = std::to_string(value) will not be executed at all for this constructor, but str will be initialized to s instead (using std::move).\nSo What is The Constructor Body For? The constructor body is still useful for performing work more complicated than just initialization. It allows us to do many things, such as:\n checking pre-conditions, like whether provided names were non-empty strings, etc. opening files and checking for success managing other resources, like network connections, VRAM buffers, etc. generally, calling member functions of our members logging the creation of our new object counting instances of our new object modifying global state in some way  As a rule of thumb, if something can be done in the member initializer list, it should. If there is no reasonable way to do it there, it should be done in the constructor body.\nSummary The correct way to initialize members in C++ is using default member initializers, or in some cases using default member initializers. The constructor body can not be used for initialization and trying to abuse it this way can lead to errors. Often, we can simply leave the constructor body empty.\nRegardless of how we initialize our members and how we order our member initializer list, the members are always initialized in the order of declaration. We have many ways to initialize members and the syntax for doing so is the same as for variables.\nSee Also  https://en.cppreference.com/w/cpp/language/constructor https://en.cppreference.com/w/cpp/language/constructor#Initialization_order https://en.cppreference.com/w/cpp/language/data_members#Member_initialization  ","wordCount":"950","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://64.github.io/cpp-faq/member-initializer-list/"},"publisher":{"@type":"Organization","name":"C++ FAQ","logo":{"@type":"ImageObject","url":"https://64.github.io/cpp-faq/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://64.github.io/cpp-faq accesskey=h title="C++ FAQ (Alt + H)">C++ FAQ</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>What is a &lsquo;Member Initalizer List&rsquo; and why should I use it?</h1><div class=post-meta><ul class=post-tags><li><a href=https://64.github.io/cpp-faq/tags/beginner/>beginner</a></li></ul></div></header><div class=post-content><p>Constructors in C++ are used to initialize the data members of a class.
First, it&rsquo;s important to understand the terminology:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>wrapper</span> {
    <span style=color:#66d9ef>int</span> value;
    
    wrapper(<span style=color:#66d9ef>int</span> v) <span style=color:#f92672>:</span> value{v}
    {
    }
};
</code></pre></div><p>Our class <code>wrapper</code> has a constructor, consisting of four parts:</p><ul><li>the class name <code>wrapper</code></li><li>the parameter list <code>int v</code> in parentheses</li><li>the member initializer list <code>value{v}</code>, separated by a <code>:</code> from the parameter list</li><li>the constructor body <code>{}</code>, which is empty in this case</li></ul><p>In most other languages that have classes and constructors, the initialization simply takes place in the constructor
body.
However, in C++, this is not possible as the constructor body can only be used for reassigning members after they have
already been initialized.</p><h2 id=a-common-mistake-trying-to-initialize-in-the-constructor-body>A Common Mistake: Trying to Initialize in the Constructor Body<a hidden class=anchor aria-hidden=true href=#a-common-mistake-trying-to-initialize-in-the-constructor-body>#</a></h2><p>Consider the following example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>point</span> {
    <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>int</span> y <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
    
    point(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y)
    {
        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>x <span style=color:#f92672>=</span> x;
        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>y <span style=color:#f92672>=</span> y;
    }
};
</code></pre></div><p>Here, when we call the constructor <code>point(int,int)</code>, the members <code>x</code> and <code>y</code> are first initialized to zero using
<a href=https://en.cppreference.com/w/cpp/language/copy_initialization>copy initialization</a>.
Afterwards, they get reassigned to the constructor parameters <code>x</code> and <code>y</code> respectively.
<strong>This is not initializing the members to the parameters. It is reassigning them.</strong></p><p>In such a trivial example, the difference isn&rsquo;t noticeable.
But if we use <code>const</code> members, reference members, array members, or any other non-assignable type, we receive
compiler errors:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>const_value</span> {
    <span style=color:#75715e>// error: uninitialized const member in &#39;const int&#39; [-fpermissive]
</span><span style=color:#75715e></span>    <span style=color:#75715e>// note: &#39;const int const_value::val&#39; should be initialized
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> val;

    const_value(<span style=color:#66d9ef>int</span> val)
    {
        <span style=color:#75715e>// error: assignment of read-only member &#39;const_value::val&#39;
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>val <span style=color:#f92672>=</span> val;
    }
};
</code></pre></div><p>In this case, we should be glad that we have received a compiler error, because there are also cases where our code
compiles but performance gets degraded, unnoticeably.
For example, if we have a <code>std::string</code> member, it may be inefficient to first initialize it to an empty string and
then reassign it to another value.</p><h2 id=the-right-way-using-a-member-initializer-list>The Right Way: Using a Member Initializer List<a hidden class=anchor aria-hidden=true href=#the-right-way-using-a-member-initializer-list>#</a></h2><p>To initialize our members, we should isntaed use a member initializer list and leave the constructor body empty:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>const_point</span> {
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> x, y;
    
    const_point(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y) <span style=color:#f92672>:</span> x{x}, y{y} {}
};
</code></pre></div><p>This code compiles, unlike the previous example.
We are taking the parameter <code>x</code> and <code>y</code> and initializing the members <code>x</code> and <code>y</code> to their values, respectively.
Unlike in the previous, incorrect example of using <code>this->x =</code> to &ldquo;initialize&rdquo;, we can just use <code>x</code> as a parameter
name without worrying about ambiguity with the members of our class.</p><p>Elements of the member initializer list are separated by a comma and follow the same syntax as initialization as
variables.
In this particular example with <code>x{x}</code>, <code>y{y}</code>, we are using
<a href=https://en.cppreference.com/w/cpp/language/list_initialization>list initialization</a> to initialize the members.
However, we could also use <code>x()</code> to <a href=https://en.cppreference.com/w/cpp/language/value_initialization>value-initialize</a>
<code>x</code> to zero, or <code>x(5)</code> to
<a href=https://en.cppreference.com/w/cpp/language/direct_initialization>direct-initialize</a> <code>x</code> to a <code>5</code>.
Once again, we have the same syntax of initializing members in the member initializer list as for variables.</p><p>The constructor body can usually be left empty if we only initialize our members.</p><h3 id=about-initialization-order>About Initialization Order<a hidden class=anchor aria-hidden=true href=#about-initialization-order>#</a></h3><p>Sometimes the order of initialization is important.
Initialization in C++ alwas takes place in the order of declaration of members inside the class, even if the member
initializer list suggests otherwise. For example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>stringified_value</span> {
    <span style=color:#66d9ef>int</span> value;
    std<span style=color:#f92672>::</span>string str;
    
    <span style=color:#75715e>// warning: &#39;stringified_value::str&#39; will be initialized after
</span><span style=color:#75715e></span>    <span style=color:#75715e>//          &#39;stringified_value::value&#39;
</span><span style=color:#75715e></span>    <span style=color:#75715e>//          when initialized here [-Wreorder]
</span><span style=color:#75715e></span>    stringified_value(<span style=color:#66d9ef>int</span> v) <span style=color:#f92672>:</span> str{std<span style=color:#f92672>::</span>to_string(v)}, value{v} {}
};
</code></pre></div><p>To avoid compiler warnings, we should always write our member initializer list in the order of declared members:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>stringified_value</span> {
    <span style=color:#66d9ef>int</span> value;
    std<span style=color:#f92672>::</span>string str;
    
    stringified_value(<span style=color:#66d9ef>int</span> v) <span style=color:#f92672>:</span> value{v}, str{std<span style=color:#f92672>::</span>to_string(v)} {}
};
</code></pre></div><h3 id=about-default-member-initializers>About Default Member Initializers<a hidden class=anchor aria-hidden=true href=#about-default-member-initializers>#</a></h3><p>Default member initializers are another correct way of initializing members.
We could make our previous example more concise using them:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>stringified_value</span> {
    <span style=color:#66d9ef>int</span> value;
    <span style=color:#75715e>// default member initializer here:
</span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>string str <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>to_string(value);
    
    stringified_value(<span style=color:#66d9ef>int</span> v) <span style=color:#f92672>:</span> value{v} {}
};
</code></pre></div><p>In this example, <code>value</code> will first be initialized to <code>v</code>, then <code>str</code> will initialized to the stringified <code>value</code>.
Remember, <code>str</code> is declared after <code>value</code>, so it&rsquo;s always initialized after.
Default member initializers are always executed for all constructors, unless they are overridden by a member initializer
list.
Say, we were to add a second constructor:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>stringified_value(<span style=color:#66d9ef>int</span> v, std<span style=color:#f92672>::</span>string s) <span style=color:#f92672>:</span> value{v}, str{std<span style=color:#f92672>::</span>move(s)} {}
</code></pre></div><p>Now <code>str = std::to_string(value)</code> will not be executed at all for this constructor, but <code>str</code> will be initialized to
<code>s</code> instead (using <a href=https://en.cppreference.com/w/cpp/utility/move><code>std::move</code></a>).</p><h3 id=so-what-is-the-constructor-body-for>So What is The Constructor Body For?<a hidden class=anchor aria-hidden=true href=#so-what-is-the-constructor-body-for>#</a></h3><p>The constructor body is still useful for performing work more complicated than just initialization.
It allows us to do many things, such as:</p><ul><li>checking pre-conditions, like whether provided names were non-empty strings, etc.</li><li>opening files and checking for success</li><li>managing other resources, like network connections, VRAM buffers, etc.</li><li>generally, calling member functions of our members</li><li>logging the creation of our new object</li><li>counting instances of our new object</li><li>modifying global state in some way</li></ul><p>As a rule of thumb, if something can be done in the member initializer list, it should.
If there is no reasonable way to do it there, it should be done in the constructor body.</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>The correct way to initialize members in C++ is using default member initializers, or in some cases using default member
initializers.
The constructor body can not be used for initialization and trying to abuse it this way can lead to errors.
Often, we can simply leave the constructor body empty.</p><p>Regardless of how we initialize our members and how we order our member initializer list, the members are <strong>always</strong>
initialized in the order of declaration.
We have many ways to initialize members and the syntax for doing so is the same as for variables.</p><h3 id=see-also>See Also<a hidden class=anchor aria-hidden=true href=#see-also>#</a></h3><ul><li><a href=https://en.cppreference.com/w/cpp/language/constructor>https://en.cppreference.com/w/cpp/language/constructor</a></li><li><a href=https://en.cppreference.com/w/cpp/language/constructor#Initialization_order>https://en.cppreference.com/w/cpp/language/constructor#Initialization_order</a></li><li><a href=https://en.cppreference.com/w/cpp/language/data_members#Member_initialization>https://en.cppreference.com/w/cpp/language/data_members#Member_initialization</a></li></ul></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://64.github.io/cpp-faq>C++ FAQ</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/cpp-faq/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>